

## 我的八股文

### 数据结构与算法

#### [10大排序](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)

[C语言实现排序算法+动图](https://mp.weixin.qq.com/s/eKU_DCU0tLwyqfVvRrSLMA)

在最坏的情况下，待排序的序列已经为正序或者逆序，快速排序的时间复杂度为`O(n^2)`

| 排序算法     | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       |
| :----------- | :------------- | :------------- | :--------- | :------------------- |
| 冒泡排序     | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| 选择排序     | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| 插入排序     | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| **快速排序** | O(n*log2n)     | O(n2)          | O(log2n)   | 不稳定               |
| 堆排序       | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定               |
| 归并排序     | O(n*log2n)     | O(n*log2n)     | O(n)       | **稳定**             |
| 希尔排序     | O(n*log2n)     | O(n2)          | O(1)       | 不稳定               |
| 计数排序     | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 |
| 桶排序       | O(n)           | O(n)           | O(m)       | 稳定                 |
| 基数排序     | O(k*n)         | O(n2)          |            | 稳定                 |

### C++基础

#### 1. static

```c++
控制变量的存储方式和可见性。 

(1)修饰局部变量
一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

(2)修饰全局变量
对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。

(3)修饰函数
用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

(4)C++中的static
如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的
```

#### 2. const的含义及使用场景和作用

```C++
const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。
 
(1)const修饰基本数据类型

 1.const修饰一般常量及数组
  
 基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 
  
 2.const修饰指针变量*及引用变量&  
 
如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

(2)const应用到函数中,  

 1.作为参数的const修饰符
 
 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。
 [注意]：参数const通常用于参数为指针或引用的情况; 
 
 2.作为函数返回值的const修饰符
 
 声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。
(3)const在类中的用法

不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行
类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。

(4)const修饰类对象，定义常量对象 
常量对象只能调用常量函数，别的成员函数都不能调用。
```

#### 3. extern

```C++
在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

注意 extern 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
```

#### 4. define宏定义与内联函数

```c++
内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令
在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
内联函数有类型检测、语法判断等功能，而宏没有
内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样
  
内联函数适用场景:
使用宏定义的地方都可以使用 inline 函数。
作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。
    
```

#### 5.虚函数： 虚函数的作用和实现原理，什么是虚函数,有什么作用?

```c++
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。	
    
动态多态满足的条件：
1. 有继承关系
2. 子类重写父类的虚函数
3. 父类的指针或者引用,执行子类对象
	
虚函数实现原理:包括虚函数表、虚函数指针等 

虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。
```

**虚函数表存放位置？linux全局数据区，windows常量段**[C++中虚函数、虚指针和虚表详解](https://blog.csdn.net/qq_20817327/article/details/108859161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164760442916780271554589%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164760442916780271554589&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-108859161.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8&spm=1018.2226.3001.4187)

每个声明了虚函数或者继承了有虚函数的类，都会有一个自己的==虚函数表vtbl==。同时该类的每个对象都会包含一个==虚指针vptr==去指向该`vtbl`。虚函数按照其声明顺序放于 `vtbl` 表中, `vtbl` 数组中的每一个元素对应一个函数指针。如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置。在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中.

如果 `normalize()`是一个 `virtual member function`，那么调用：**`ptr->normalize();`**

实际上会被编译器转化为：**`(*ptr->vptr[1])(ptr);`**

- `vptr` 是指向虚函数表的指针
- `1` 是表中该函数的索引，
- `ptr` 表示的是`this`指针

一个类只有一个虚函数表，每个表中可能含有三种类型的虚函数：

- 此类定义的函数实例。包括重写了父类中的虚函数
- 从父类中继承的且没有重写的虚函数
- 纯虚函数

#### 6. **内联函数、构造函数、静态成员函数、模板函数可以是虚函数吗?**

对于虚函数有几点关键点：

- 虚函数是属于对象的
- 虚函数的和运行时期有关

由以上两点，可以回答原问题。

- `inline`：`inline` 需要在编译期就确定类的信息，但是虚函数具体是属于哪个类的，只有在动态运行时才能知道。
- `static`：静态函数是没有 `this` 指针，而虚函数是属于某个对象的`this`与`vptr`来调用的。
- `constructor`：虚函数等到运行时才知道是调用了哪个对象的虚函数。如果构造器也是虚函数，对象都无法构建。因此，构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被 `disable` 的。
- 模板函数 模板函数也不能是虚函数。因为，类会在`vtbl`中存放类中的所有的虚函数的函数指针，而一个模板函数如果设计为虚函数是无法获悉这个模板函数会被实例化为哪些具体的函数。

#### 7. **为什么需要虚析构函数，什么时候不需要? 父类的析构函数为什么要定义为虚函数**

- 一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是**为了当用一个基类的指针删除一个派生类的对象时， 派生类的析构函数会被正确调用**。
- 当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。 所以，**只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**

#### 8.纯虚函数，为什么需要纯虚函数？

```c++
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

virtual void funtion1()=0

原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)
纯虚函数不同的是父类绝对不能实现，且不能实例化，子类必须实现父类定义的虚函数接口，除非它也想成为抽象类，抽象类可以有部分方法实现，但至少要有一个纯虚函数的类才能叫抽象类。
Class B
{
public:
    virtual void fun1(){ cout << "fun1";} //虚函数，子类不用声明或实现
    virtual void fun2 = 0; //纯虚函数，子类必须声明并实现
};              
```

#### 9.[虚析构函数（√）、纯虚析构函数（√）、虚构造函数（X）](https://www.cnblogs.com/chio/archive/2007/09/10/888260.html)

#### 10. STL迭代器失效(拓跋阿秀八股)

> STL中迭代器失效的情况有哪些？
> **以vector为例：**
> 插入元素：
> 		1、尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
> 		2、中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size ==
> capacity时，所有迭代器均失效。
> 删除元素：
> 		1、尾后删除：只有尾迭代失效。
> 		2、中间删除：删除位置之后所有迭代失效。
> **deque 和 vector 的情况类似,**
> list双向链表每一个节点内存不连续, **删除节点仅当前迭代器失效**,erase返回下一个有效迭代器;
> map/set等关联容器底层是红黑树**删除节点不会影响其他**节点的迭代器, 使用递增方法获取下一个迭代器
> mmp.erase(iter++);
> unordered_(hash) 迭代器意义不大, **rehash之后, 迭代器应该也是全部失效**. 

#### 11.右值引用与move语义

- 左值和右值的区别

  > 如`int a = 5 中的变量是左值，5是右值  `；
  >
  > 左值就是有名字的变量（对象），左值必须要在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中有实体；可以被赋值，可以在多条语句中使用，比
  >
  > 而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值
  >
  >  一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址

- [一文读懂C++右值引用和std::move—————详细好文](https://zhuanlan.zhihu.com/p/335994370)

- [c++ 之 std::move 原理实现与用法总结](https://ppipp.blog.csdn.net/article/details/84644069)
  - 在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是**将一个左值强制转化为右值引用，继而可以通过右值引用使用该值**，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);
  - C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
  - std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。原左lvalue值被moved from之后值被转移,所以变为空.

#### 12.数组vector与链表list的区别

- 为什么[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)比链表查询速度更快？
  - 数组由于是紧凑连续存储,可以随机访问，通过**索引**快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
  - 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。
- 数组(**顺序存储**)和链表（**链式存储**）有以下不同：
  - **数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。**
  - *存储形式**：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个节点要保存相邻结点指针；**
  - **数据**查找**：数组的**线性查找速度快，查找操作直接使用偏移地址**。链表需要**按顺序检索结点**，效率低；**
  - **数据**插入或删除**：链表可以快速插入和删除结点，而数组则可能需要大量数据移动；**
  - 越界问题**：链表不存在越界问题，数组有越界问题。

#### 13.常量指针和指针常量的区别：

> const pointer，指针本身是一个常量，指向的地址不能改变，里面的内容可以修改。（门牌号11，不管里面住谁，我指向的都是这条街11号）
> pointer to const，指向的内容是一个常量，可以改变指向的地址，只要新地址里面也是常量就好。（小明原来住在六舍356，后来搬到357，不管是356还是357，里面住的都是小明）
>
> 当然如果单纯为了区别两个中文，那么const=常量，*=指针，看谁在谁前面就叫对应的名字。

#### 14.[c语言如何实现多态](https://blog.csdn.net/wenqiang1208/article/details/76244628)

#### 15.介绍c语言指针

<img src="https://img-blog.csdnimg.cn/20200511093640946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIxNzU3Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" />

1. 指针的定义：指针是一个变量，用来存放地址的变量
2. 指针的类型：
   - 基本类型：int 、short、long、float 、double、char
     如 int *p；//表示定义一个指针，这个指针指向整形变量，这个指针将存放的是整形变量的地址。*
   - **数组指针：**指针指向一个数组
     `int (*a) [10]`表示指针a指向一个int型的长度为10的数组
   - **函数指针：**指针指向一个函数
     `void (*a) ();`/表示指针指向一个无参数无返回值的函数
3. 指针的引用：指针引用后得到的是该地址所对应的变量的值。
4. 二级指针：指向一级指针地址的指针
5. 指针的运算：
   - 指针`+`或者`-`一个数，表示指针加减这个数的类型所占内存的整数倍
     如` int *p=a;p=p+2;` , 在VC6.0里面，实际上p加了2 * 4=8
   - 指针减去一个指针，表示**两个指针之间所差的内存单元或者元素个数**，两个指针相加没有意义
   - 关系运算，如果定义了两个指针变量p和q，并且都已经初始化了，
     - 如果`p==q`，则表示p和q指向同一个地址
     - `p>q`,则表示p指向高地址而q指向低地址
     - 也经常拿`p和NULL`做比较，用来表示指针当前的状态，这在数据结构中应用非常广泛，比如说链表节点的查找、判断是否为空等等
6. 指针和数组的关系：
   指针和数组关系密切，数组可以通过指针去引用，数组可以存放指针，数组也可以由指针去访问，指针也能存放数组的地址

#### 16.this指针是什么？调用函数的过程？

[C++ this指针详解（精辟） (biancheng.net)](http://c.biancheng.net/view/2226.html)

[C++中this指针的用法详解 - 优秀afa - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhengfa-af/p/8082959.html)



#### 17.智能指针`share_ptr`怎么实现的？是线程安全的吗？

1. 首先说一下为什么使用智能指针？

   > 智能指针是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的  
   >
   > 智能指针其作⽤是管理⼀个指针，避免咋们程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。
   >
   > 因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。   

2. `shared_ptr`的实现机制是**==在拷⻉构造时使⽤同⼀份引⽤计数==**  

   > （1）⼀个模板指针`T* _ptr`，指向实际的对象
   > （2）⼀个引⽤次数
   >           必须new出来的，不然会多个shared_ptr⾥⾯会有不同的引⽤次数⽽导致多次delete
   > （3）重载operator*和operator->
   >           使得能像指针⼀样使⽤shared_ptr
   > （4）重载copy constructor
   >           使其引⽤次数加⼀（拷⻉构造函数)
   > （5）重载operator=（赋值运算符）
   >           比如将b赋值给a，如果原来的shared_ptr a已经有对象，在赋值操作执行则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象引⽤次数加⼀
   > （6）重载析构函数
   >           使引⽤次数减⼀并判断引⽤是否为零; (是否调⽤delete)  

3. `shared_ptr`的线程安全问题

   >（1）同⼀个shared_ptr被多个线程“读”是安全的;
   >（2）同⼀个shared_ptr被多个线程“写”是不安全的;
   >证明：在多个线程中同时对⼀个shared_ptr循环执⾏两遍swap。 shared_ptr的swap函数的作⽤就是和另外⼀个shared_ptr交换引⽤对象和引⽤计数，是写操作。执⾏两遍swap之后, shared_ptr引⽤的对象的值应该不变）
   >（3）共享**引⽤计数的不同**的shared_ptr被多个线程”写“ 是安全的  

```c++
template<typename T>
class SharedPtr
{
private:
    T* _ptr; // (1)
    int* _pcount; // 指向引用计数的指针
public:
    // 初始化构造函数（有参数）
    SharedPtr(T* ptr == NULL): _ptr(ptr), _pcount(new int(1)) {}; // 初始化列表构造函数？
    // (3)
    T& opertor*() { // 返回智能指针this维护的指针_ptr指向的实际对象
        return *(this->_ptr);
    }
    T* opertor->() { // 返回该智能指针this中维护的指针_ptr
        return this->_ptr;
    }
    // (4)拷贝构造函数
    SharedPtr(const SharedPtr& s): _ptr(s._ptr), _pcount(s._pcount) {
        (*_pcount)++; // 当前对象的引用计数加一
    }
    // (5)重载=
    SharedPtr<T>& opertor=(const SharedPtr& s) {
        if (this != &s) {
            if (--(*(this->_pcount)) == 0) {
                delete this->_ptr;
                delete this->_pcount;
            }
            _ptr = s._ptr;
            _pcount = s._pcount;
            *(_pcount)++;
        }
        return *this;
    }
    // (6)
    ~SharedPtr() {
        --(*(this->_pcount) == 0) {
            delete _ptr;
            _ptr = NULL;
            delete _pcount;
            _pcount = NULL;
        }
    }
}
```



#### 18.[内存泄露和内存溢出的区别和联系及产生原因](https://www.cnblogs.com/pan-louis/p/10768340.html)

一、什么是[内存溢出](https://so.csdn.net/so/search?q=内存溢出&spm=1001.2101.3001.7020)和内存泄露

1、内存泄漏（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。
2、内存溢出 （out of memory）：:指程序申请内存时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。也就是说给你个int类型的存储数据大小的空间，但是却存储一个long类型的数据，这样就会导致内存溢出。
二、内存溢出和[内存泄露](https://so.csdn.net/so/search?q=内存泄露&spm=1001.2101.3001.7020)的关系以及区别

1.关系：**内存泄露最终会导致内存溢出**，由于系统中的内存是有限的，如果过度占用资源而不及时释放，最后会导致内存不足，从而无法给所需要存储的数据提供足够的内存，从而导致内存溢出。导致内存溢出也可能是由于在给数据分配大小时没有根据实际要求分配，最后导致分配的内存无法满足数据的需求，从而导致内存溢出。

2.区别：内存泄露是由于GC无法及时或者无法识别可以回收的数据进行及时的回收，导致内存的浪费；内存溢出是由于数据所需要的内存无法得到满足，导致数据无法正常存储到内存中。内存泄露的多次表现就是会导致内存溢出。

> 内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越长，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。
>
> 内存泄漏的分类
>
> （1）堆内存泄漏 （Heap leak）
> 对内存指的是程序运⾏中根据需要分配通过malloc,realloc new等从堆中分配的⼀块内存，再是完成后必须通过调⽤对应的 free或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使⽤，就会产⽣ Heap Leak.
> （2）系统资源泄露（Resource Leak）
> 主要指程序使⽤系统分配的资源⽐如 Bitmap,handle ,SOCKET 等没有使⽤相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运⾏不稳定。
> （3）没有将基类的析构函数定义为虚函数
> 当基类指针指向⼦类对象时，如果基类的析构函数不是 virtual，那么⼦类的析构函数将不会被调⽤，⼦类的资源没有正确是释放，因此造成内存泄露。  

> 避免内存泄露的几种方式
>
> （1）使用智能指针，是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的  
>
> （2）计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如
> 果不为0则表示存在内存泄露
>
> （3）一定要将基类的析构函数声明为虚函数
> （4）对象数组的释放一定要用delete []
> （5）有new就有delete，有malloc就有free，保证它们一定成对出现  

> 如何检测内存泄漏
> （1）⾸先可以通过观察猜测是否可能发⽣内存泄漏， Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
> （2）还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、 vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
> （3）当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 ，Linux下可以使用Valgrind工具
> Windows下可以使用CRT库 



---



### 项目

#### 1. 服务器端实现高并发——项目设计

1. TCP`socket,bind,listen...`+多线程

   - 优点：代码简单，结构清晰，把各种功能的业务代码放到线程函数里
   - 缺点：对服务器性能要求比较高，比如，虚拟机（1G内存，单核CPU，大概能够接受300个这种结构客户端的请求，如果再多，服务器创建线程时报错：内存不够）
   - 多线程只有在多核CPU上，才能体现出真正的并发优势，我们使用的阿里云轻量服务器是单核的，单核CPU使用多线程是一种伪并发，线程之间切换也需要时间
   - 综上：效率不高

2. select：文件描述符（对应一个客户端）的集合，单线程循环，对服务器性能要求相对较低，但是并发量有限（1024），处理效率低，一旦有数据可读的时候，需要循环遍历整个集合

3. epoll：对服务器性能要求相对较低，理论上并发量无限（资源毕竟有限，终将会消耗完），处理效率高，一旦有数据可读的时候，自己`epoll_event`事件结构体会直接跳出来，但是，缺点：同步（某个客户端的请求处理比较麻烦耗时，那么其他客户端在此期间的请求会监听不到）

4. epoll+多线程：解决3的缺点，epoll监听到某个客户端请求，启动一个线程，把他教给线程去处理，epoll本身继续执行监听任务，缺点：频繁启动线程，浪费时间和资源

5. epoll+线程池：解决4缺点，线程池是在服务器空闲的时候提前建立大量的线程，等待使用，处理完某个客户端请求之后，再把线程放回到线程池中

6. libevent（底层封装了epoll），集合中的事件不同于epoll中的epoll_event，叫做`buffer_event`，还封装了`TCP中的各种函数`，稳定；既然是封装了epoll，也是一种同步方式

7. ==本项目==：libevent+多线程，但是不同于4，因为`libevent`也是不允许多个线程同时操作事件集合`event_base`，涉及到同步问题，而且高并发下，多线程将资源会耗尽

   所以管理线程（监听），处理客户端请求时，新建工作线程（在这个里面再创建一个事件集合，）

   一个线程中只有一个事件，没有体现出libevent事件集合的优势

==**最好的实现方案设计：**==

- 聊天等功能时，使用`libevent+单线程`，因为聊天等功能都比较简单，不会很时，造成单线程的堵塞问题，且单线程下使用io多路复用可以处理高并发的聊天请求
- 传输文件功能时，再启用额外的线程，处理这种比较耗时的工作

#### 1.说一下项目的难点

> 1. 考虑使用**多线程**解决高并发下处理用户请求、发送文件可能造成的堵塞，与单线程io多路复用文件发送依然会造成堵塞，影响用户在此期间的聊天功能
> 2. 实现登录功能时用户密码的加密问题
>    - 直接存储原密码，很容易泄露造成安全问题
>    - md5，使用某种哈希函数对原密码加密
>    - 一种**[彩虹表算法](https://blog.csdn.net/nie19940803/article/details/76641498)**专门用来破解哈希加密
>    - 防御彩虹表的一种方法是提高hash函数的计算难度，但是提高单次hash的计算难度有违hash的设计初衷。
>    - 综上，我才用==加盐`salt`+哈希函数加密==，防御彩虹表的破解
>      - 加盐是指通过在密码任意固定位置插入特定的字符串，让[散列](https://so.csdn.net/so/search?q=散列&spm=1001.2101.3001.7020)后的结果和使用原始密码的散列结果不相符
>      - 加入破解者知道盐值和插入位置，也需要针对加盐的hash函数做对应的R函数修改，因此已有的彩虹表数据就完全无法使用，必须针对特定的H重新生成，这样就**提高了破解的难度**。

#### 2. 任意hash函数应具备的特点

> 1.      压缩性：对于任意给定输入有唯一特定长度输出，例SHA1的hash值为20字节。
>
> 2.      容易计算：即从原始数据计算hash值应该很容易。
>
> 3.      抗修改：对原始数据哪怕1bit的修改都会对hash值产生重大影响。
>
> 4.      抗碰撞：这里分为强碰撞和弱碰撞，弱碰撞是给定一个数据很难找出相同hash值得另外一个数据。强碰撞是很难找出hash值相同的两个数据。

#### 3. libevent介绍

> 常见的I/O编程框架：
>
> 对比几个常见的I/O编程框架：libevent，libev，libuv，aio，boost.Asio。
>
> libevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。
> 设计模式 ：libevent为Reactor模式；
> 层次架构：livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务；
> 可移植性 ：libevent主要支持linux平台，freebsd平台，其他平台下通过select模型进行支持，效率不是太高；
> 事件分派处理 ：libevent基于注册的事件回调函数来实现事件分发；
> 涉及范围 ：libevent只提供了简单的网络API的封装，线程池，内存池，递归锁等均需要自己实现；
> 线程调度 ：libevent的线程调度需要自己来注册不同的事件句柄；
> 发布方式 ：libevent为开源免费的，一般编译为静态库进行使用；
> 开发难度 ：基于libevent开发应用，相对容易，具体可以参考memcached这个开源的应用，里面使用了 libevent这个库。

---

### 计算机网络

#### `http header`有什么内容

[`http`面试问题集锦](https://www.cnblogs.com/rachelxiao/p/12423095.html )

#### [TCP粘包问题](https://blog.csdn.net/weixin_41047704/article/details/85340311?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&utm_relevant_index=12)

>  “粘包问题”的概念用一句话说：就是，不同结构的多个包合成了一个大包，从而不知道怎么去把这个大包分割出原来的包。
>
> 解决方式：
>
> 1. 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
> 2. 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

#### **TCP如何保证可靠性**

- 首先，TCP的连接是基于三次握手，而断开则是四次挥手。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在有状态;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在可控制。它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

#### TCP流量控制——by滑动窗口

#### 拥塞控制算法

TCP四大拥塞控制算法总结？（极其重要）  ——————拓跋阿秀的八股文

[《计算机网络》学习笔记 NO.029 TCP协议的拥塞控制](https://mp.weixin.qq.com/s/rqyc8zaW-7-pFTjO-N3p3A)

1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速恢复

#### 如何区分流量控制和拥塞控制？

- 流量控制属于通信双⽅协商；拥塞控制涉及通信链路全局。
- 流量控制需要通信双⽅各维护⼀个发送窗、⼀个接收窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化由试探性发送⼀定数据量数据探查⽹络状况后⽽⾃适应调整。
- 实际最终发送窗⼝ = min{流控发送窗⼝，拥塞窗⼝}  

#### 解释一下超时重传和快速重传的区别

#### 快速重传为什么是3次ack以后才开始

- 主要是为了区分包的丢失，是由什么原因引起的
  - 1、包checksum出错
  - 2、网络拥塞
  - 3、网路断
- 如果在反向还可以接受到发送数据包的ack，可以认为网络没有断，否则也收不到ack，排除3
- 如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，
  接收方会进行排序工作  
- 如果接收到三个或三个以上的duplicated ACK，则大概率是丢包  ，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，说明先前的发送的包出错了，则一切OK，流速依然。  而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理  

#### 在浏览器中输入**url**地址后显示主页的过程?  

- 根据域名，进行**DNS域名解析**；
- 拿到解析的IP地址，建立TCP连接；  
- 向IP地址，发送HTTP请求；
- 服务器处理请求；
- 返回响应结果；
- 关闭TCP连接；
- 浏览器解析HTML；浏览器布局渲染；  

#### DNS域名解析过程

（找到客户端发起的某个web服务器（域名：www.baidu.com）对应的IP地址)

浏览器的缓存——>系统hosts文件——>本地DNS服务器——>根域名服务器——>顶级域名服务器——>权限域名服务器。

> 1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器
>
> 2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找
>
> 3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器
>
> 4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址
>
> 5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器
>
> 6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息
>
> 7、客户机的本地的dns服务器会将查询结果返回给我们的客户机
>
> 8、客户机根据得到的ip信息访问目标主机，完成解析过程

两种查询方式：==微信收藏文章看图片==

递归查询：本地域名服务器作为DNS客户端的身份，递归的方式向其他更高级别的域名服务器进行递归查询，代替主机/客户端查询

迭代查询：当根域名服务器x本地服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该找哪个域名服务器y进行查询，然后本地服务器向y进行相同方式的迭代查询

#### **SYN攻击是什么？**

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间**占用未连接队列**，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
==检测 SYN 攻击==非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基
本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击  。

`netstats -n -p TCP | grep SYN_RECV`

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

==优化方式：==

1. 缩短SYN Timeout时间
2. 记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。

#### HTTPS的连接过程

> 1. 浏览器将支持的加密算法信息发给服务器
> 2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
> 3. ==客户端(SSL/TLS)解析证书验证证书合法性==，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
> 4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
> 5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
> 6. 服务器将加密后的密文发送给客户端
> 7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

#### HTTPS客户端验证CA机构颁发给服务器的数字证书过程

> 1. 什么是数字证书？
>
>    - 服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：**证书内容、证书签名算法和签名**，签名是为了验证身份。
>
>    - **数字签名的制作过程**：
>      1. CA使用证书签名算法对证书内容进行**hash运算**。
>      2. 对hash后的值**用CA的私钥加密**，得到数字签名。
>
> 2. 服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站
>
> 3. **浏览器验证过程**：
>
>    1. 获取证书，得到证书内容、证书签名算法和数字签名。
>    2. 用CA机构的公钥**对数字签名解密**（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。
>    3. 用证书里的签名算法**对证书内容进行hash运算**。
>    4. 比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。

#### 常用对称与非对称加密算法有哪些

先复习一下相关概念：

> - 明文：指没有经过加密的信息/数据。
> - 密文：明文被加密算法加密之后，会变成密文，以确保数据安全。
> - 密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。
> - 加密：将明文变成密文的过程。
> - 解密：将密文还原为明文的过程。

对称加密算法:加密和解密使用**相同密钥**的加密算法。常见的对称加密算法有**AES、3DES、DES、RC5、RC6**等。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmRWNuUibfyQusbEibTQ1kuW4Bl7e4x0g9ra3KVjJCWFpiaKtcVH6ZxpKRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**非对称加密算法**：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。主要的非对称加密算法有：**[RSA](https://blog.csdn.net/a745233700/article/details/102341542)、Elgamal、DSA、D-H、ECC**。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmQWfgJ9BeRH1f0CPUhhTBO7POHoLwwUibkjdLwepWkgFCP0kNXpSwm9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

#### [ARP与RARP协议](https://blog.csdn.net/dan15188387481/article/details/49823729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164896958216782092956115%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164896958216782092956115&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-49823729.142^v5^pc_search_result_cache,157^v4^control&utm_term=ARP%E4%B8%8ERARP%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187)

> 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，
> 并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议
> 是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击
> 者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地
> 址的对应关系、添加或删除静态对应关系等。
>
> arp解析过程：
> 1.若A要知道B的mac地址，先判断自己的rap缓冲区中是否有B的ip和mac的映射，如果有，则直接得到B的mac地址，若没有，则发送rap广播请求包给该网络上的所有主机
> 2.该网络上所有主机收到请求包后打开传给自己的上层----网络层，网络层判断是否是给自己的信息（判断数据包中的目的IP是否和自己的IP一样），若不是，则丢弃，若是（也就是B收到了），则将A的amc地址填充到自己的arp缓冲区中（方便下次使用），并将自己的mac地址填充到响应包中发送给A
> 3.A收到响应包后就知道了B的mac地址，然后将这个mac地址填充到自己的arp缓冲区中
> 此外，若该网络中不存在B，即地址不可达，则A会收到一个地址不可达的ICMP包。ICMP（Internet控制报文协议）工作在网络层，用于传递差错信息，时间，回显等控制数据。
>
> 教材上把ARP协议划到网络层，是因为ARP协议属于TCP/IP协议簇。在TCP/IP模型中，它所有定义的协议是在网际层上的。
>
> 再看按照OSI的标准，数据在传递时每层会加上自己的信息。当网络层的IP包进入链路层时，链路层通过ARP协议添加链路信息，而这不是网络层的功能。
>
> 所以有很多人说ARP是链路层的。
>
> 可以这样做，在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。
>
> 考试我们要按教材做，接网络层。



<img src="https://img-blog.csdnimg.cn/20191019105720115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcnRfX19fMzM5,size_10,color_FFFFFF,t_70" alt="img" style="zoom:33%;" />

#### `ping baidu.com`发生了什么

> 1、首先进行DNS域名解析得到目标主机对应的ip地址
>
> - 主机查找本地系统Hosts文件的DNS缓存，如果存在www.baidu.com对应的IP,则获取IP；
> - 若本地系统没有对应IP，主机操作系统生成一个DNS查询报文，将[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)www.baidu.com放入DNS报文段中，进行DNS域名解析

> 2、`ping`过程：
>
> - `ping`命令的作用和原理
>   - 「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。
>   - ping 命令是基于` ICMP 协议`来工作的，`ICMP协议`是`“Internet Control Message Protocol”（因特网控制消息协议）`的缩写。它是`TCP/IP协议族`的一个子协议，用于在`IP主机、路由器`之间传递控制消息。`ping 命令`会发送一份`ICMP回显请求报文`给目标主机，并等待目标主机返回`ICMP回显应答`。因为`ICMP协议`会要求目标主机在收到消息之后，必须返回`ICMP应答消息`给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。
>   - [补充：什么是`ICMP`？](https://smile.blog.csdn.net/article/details/82782962)
>
> - 举一个例子来描述**「ping」命令的工作过程**：
>
> 1. 假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2
> 2. 此时，ping命令会在主机A上**构建一个 ICMP的请求数据包**（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。
> 3. IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，**构建成一个IP数据包**。
> 4. IP数据包构建完成后，还不够，还需要**加上MAC地址**，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并**交给数据链路层，组装成一个数据帧**，依据以太网的介质访问规则，将它们传送出出去。
> 5. 当主机B收到这个数据帧之后，会**首先检查它的目标MAC地址是不是本机**，**如果是就接收下来处理**，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会**构建一个ICMP应答数据包，回发给主机A**
> 6. **在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达**。**除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。**

#### [udp如何实现可靠传输](https://www.cnblogs.com/williamjie/p/11133180.html)

> UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。
>
> 传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
>
> 最简单的方式是**在应用层模仿传输层TCP的可靠性传输**。下面不考虑拥塞处理，可靠UDP的简单设计。
>
> - 1、添加seq/ack机制，确保数据发送到对端
> - 2、添加发送和接收缓冲区，主要是用户超时重传。
> - 3、添加超时重传机制。
>
> **详细说明：**送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。
>
> 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
> 发送：包的分片、包确认、包的重发
> 接收：包的调序、包的序号确认
>
> 目前有如下开源程序利用udp实现了可靠的数据传输。分别为***RUDP、RTP、UDT***:
>
> ##### 1、RTP（Real Time Protocol）
>
> *RTP为数据提供了具有实时特征的端对端传送服务*，如在组播或单播网络服务下的交互式视频音频或模拟数据。
>
> 应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。
>
> RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。
>
> ##### 2、RUDP（Reliable User Datagram Protocol）
>
> *RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等*，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。
>
> ##### 3、UDT（UDP-based Data Transfer Protocol）
>
> 基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。*UDT的主要目的是支持高速广域网上的海量数据传输*，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。
>
> 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。

---



### 操作系统

#### [协程和线程的区别，线程与进程的区别](https://www.cnblogs.com/bandaoyu/p/14624968.html)

#### 内核态和用户态

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：**系统调用，异常和外围设备的中断**

[这次答应我，一举拿下 I/O 多路复用！](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

[面试官: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)

零拷贝

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

[看零拷贝之传统IO、mmap、sendfile、sendfile再优化](https://blog.csdn.net/Youth_lql/article/details/115524139)

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

**零拷贝**实现思想，就利用了**虚拟内存**这个点：多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，**就可以减少IO的数据拷贝次数啦**，示意图如下：

<img src="C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220303195205781.png" alt="image-20220303195205781" style="zoom:50%;" />

#### 进程间通信

即IPC机制——Inter-Process Communication

[凉了！张三同学没答好「进程间通信」，被面试官挂了....————————小林大佬，面试回答总结部分](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)

**什么是虚拟内存**

> 虚拟内存，是虚拟出来的内存，它的核心思想就是确保每个程序拥有自己的地址空间，地址空间被分成多个块，每一块都有连续的地址空间。同时物理空间也分成多个块，块大小和虚拟地址空间的块大小一致，操作系统会自动将虚拟地址空间映射到物理地址空间，程序只需关注虚拟内存，请求的也是虚拟内存，真正使用却是物理内存。

现代操作系统使用**虚拟内存**，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：

- 虚拟内存空间可以远远大于物理内存空间
- 多个虚拟内存可以指向同一个物理地址

#### [多线程访问共享资源——面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ)

#### **Linux常见命令：**

`/proc` 目录下都是虚拟文件，包含内核以及操作系统相关的动态信息

- linux下如何查看cpu信息——可以从文件cpuinfo读取，`cat /proc/cpuinfo`，可以查看几个cpu、单个cpu的物理核数、总逻辑核数等
- [linux系统命令之查看内存使用情况](https://blog.csdn.net/renfufei/article/details/105851728)
  - 包括物理内存RAM和交换内存
    - 使用`free -m`命令
    - 查看`/proc/meminfo`文件
    - 使用`vmstat -s`命令
    - `top` 命令一般用于查看进程的CPU和内存使用情况；当然也会报告内存总量，以及内存使用情况，所以可用来监控物理内存的使用情况
  - 查看物理内存的硬件信息，可以使用 `demidecode` 命令
- 查询操作系统中的进程——`ps或者top（进程的CPU和内存使用情况）` 
- 查看端口号命令——` lsof 和 netstat命令`
- 怎样更改文件的所属用户：`chown`
- linux命令`|`是无名管道，linux命令`mkfifo`是==命名管道

---

### Redis

#### [Redis 的五种基本数据类型](https://mp.weixin.qq.com/s/u7738xkNuH2uPwdk8_Evjw)

#### redis分布式锁

- setnx
- lua
- redisson
- RedLock

[面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)

[Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)

表锁和行锁应用场景，什么条件下会触发，间隙锁

[mysql的锁🔒](https://mp.weixin.qq.com/s/ptCOFqSuMBHm_4OmFPV2dg)

redis应用场景

部署redis集群

redis数据结构，跳表

[跳表：为什么 [Redis]一定要用跳表来实现有序集合？](https://blog.csdn.net/qq_38545713/article/details/105439688)

https流程说一下

redis主机宕机，从服务器升级为主服务器流程

[面试官：Redis主节点宕机，如何处理？](https://mp.weixin.qq.com/s/bifB1blF_YeWsNNIybmB4w)

[如何分配客户端的请求给服务器（节点）进行处理，一致性哈希是什么，使用场景，解决了什么问题？](https://mp.weixin.qq.com/s/Os2JOInK5PBLBCwUzh8Jfg)

[**那你再跟我说说Redis如何实现高可用吧？**](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)

[Redis高可用方案：sentinel（哨兵模式）和集群](https://mp.weixin.qq.com/s/2LDkEMXDLAHroyr0uFb9sQ)

- 主从复制
- 哨兵``
- 集群`cluster`

[Redis 主从复制以及主从复制原理](https://mp.weixin.qq.com/s/NL-eSf5EXLtVZgDfC_q-LQ)

---

### MySQL

==mysql如何判断事务是否提交了==

- [x] 内链接、左联结、右联结的区别————csdn八股文收藏

#### [MySQL主从复制原理以及过程以及用到的三个重要线程](https://blog.csdn.net/jiayoudangdang/article/details/123167600)

#### 所谓==慢查询==

是指在Mysql中执行时间超过指定阈值的语句将被记录到慢查询文件中

 [你好，面试官 | 分析一下SQL执行慢的原因？如何排查，优化思路？（加餐篇）](https://mp.weixin.qq.com/s/XtjVp363Rev6EBHRzPtbhA))

#### [MySQL解决幻读——MVCC与临键锁](https://blog.csdn.net/QAQ123666/article/details/105084758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164792119816780265410477%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164792119816780265410477&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-105084758.142^v3^pc_search_result_cache,143^v4^control&utm_term=mvcc%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB&spm=1018.2226.3001.4187)

当前读：读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。

> 　　select...lock in share mode (共享读锁) 
>
> 　　select...for update（行级锁）
>
> 　　update , delete , insert

快照读：快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

> ​	不加锁的select操作

**在RR级别下，==快照读/普通读==是通过[MVVC(多版本控制)+undo log](https://blog.csdn.net/weixin_45325628/article/details/123292887?spm=1001.2014.3001.5502)来实现的，==当前读==是通过加record lock(记录锁/行锁)和gap lock(间隙锁)来实现的。**

当前读的幻读与解决方式：临键锁next-key locks = 行锁+间隙锁，在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。select * from table where id>3 锁住的就是id=3这条记录以及id>3这个区间范围，锁住索引记录之间的范围，避免范围间**插入**记录，以避免**产生幻影行**记录；

> 行锁（Record Lock）：锁直接加在索引记录上面。
>
> 间隙锁（Gap Lock）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。
>
> Next-Key Lock ：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身 。

**mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。**

**快照读的幻读是用MVCC解决的，当前读的幻读是用间隙锁解决的。**

[在RR级别下，mysql通过间隙锁可以防止幻读——插入](https://blog.csdn.net/m0_37556444/article/details/104479489)

#### innodb自动使用间隙锁的条件：

（1）必须在RR级别下（**解决幻读**）
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）



---

### 分布式加分项

CAS和ABA问题

**==对分布式的了解？==**

首先说一下cap和base理论，然后往分布式锁、负载均衡、redis集群高可用，去主动靠

目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。**分布式的CAP理论**告诉我们“任何一个分布式系统都无法同时满足**一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）**，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要**牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性**”，只要这个最终时间是在用户可以接受的范围内即可。

> **CAP**
>
> CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
>
> - 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
> - 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
> - 分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

> **BASE理论**
>
> BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
>
> - Basically Available（基本可用）
> - Soft state（软状态）
> - Eventually consistent（最终一致性）

- 分布式系统设计与开发
  - 分布式缓存
  - 分布式锁
    - [面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)
    - [Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)
- 分布式事务(解决方案)
- 负载均衡技术（在nginx服务器中配了3个tomcat服务器，每个tomcat服务器上都部署了整个系统，那么当请求数大的时候，可以分发到不同的tomcat。）
- 一致性哈希算法：很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。
  - 哈希环（通过虚拟节点提高均衡度）、redis哈希槽
- 系统容灾技术————mysql主从复制，redis持久化，哨兵监控、主复制写，从负责读
- 高可用系统————主从复制、哨兵监控（自动故障转移、恢复），集群（扩展单一服务器写能力和存储能力不足）

---

### 场景题

#### 1. [Bitmap有什么用大量数据的快速排序、查找、去重](https://www.cnblogs.com/cjsblog/p/11613708.html)

#### 2.10亿个数字，内存限制100M，进行排序

>  分治法：拆分小文件，先对每个小文件进行排序，然后使用小顶堆或大顶堆合并文件

#### 3.30亿数据下怎么去重，内存限制1G

> 

#### 3.[如何保证mysql和redis的数据一致性？](https://www.cnblogs.com/shier-dong/p/15347134.html)

---

### 刷题

- 面试题16.10 生存人数（求多个区间的最大重合数量，及其对应的区间）——前缀和

- 数组中的第K个最大元素——快排

- 有序数组删除重复数字

- 给出0和1构成的二维数组，找出全部由0或者1构成的正方形边的最大值，——动态规划==[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)==

- [[380. O(1) 时间插入、删除和获取随机元素]](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/solution/chang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-j/)

  - 动态数组存储插入元素，哈希表存储元素在数组中的索引位置
  - 删除元素，首先判断是否在哈希表中，若存在，找到其索引`curInd`，在数组中交换索引`curInd`与`len-1`对应的值，将交换后的数组末尾元素删除，将其在哈希表中的索引也删除，同时更新原来末尾元素在哈希表中的索引为`curIdx`
  - 返回随机元素，`return nums(rand() % len);`

- [719找出第k小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

  - 双指针+二分法

  - 类似于————第k小的子数组和

    ```c++
    // 保证数组元素均为>= 0
    #include <bits/stdc++.h>
    using namespace std;
    int check(vector<int> &nums, int mid) { // 双指针法求小于等于mid的连续子数组个数
        int res = 0;
        int i = 0;
        int preSum = 0;
        for (int j = 0; j < nums.size(); j++) {
            preSum += nums[j];
            while (preSum > mid) { // 不必限制i <= j
                preSum -= nums[i];
                i++;
            }
            res += j - i + 1; // [i, j]可以组成(i)/(i,i+1)/(i,i+2)...(i,j-1)/(i,j)共i - j + 1个连续子数组
        }
    }
    int num_k_less_sum(vector<int> &nums, int k) { // 二分法求第k小的子数组和
        int l = 0, r = 1e9, mid, ans; // l为可能存在的最小数组和，r为最大
        while (l <= r) {
            mid = (l + r) >> 1;
            if (check(nums, mid) >= k) { // 子数组和小于等于mid的个数多于k个，说明r过大，需要缩小 
    			r = mid - 1;
                ans = mid; // 记录结果
            } 
            else {
                l = mid + 1;
            }
        }
        return ans;
    }
    int main() {
        int n, k;
        cin >> n >> k;
        vector<int> nums(n, 0);
        for (int i = 0; i < n; i++) {
            int num;
            cin >> num;
            nums[i] = num;
        }
        cout << num_k_less_sum(nums, k) << endl;
    }
    ```


- [694 不同岛屿（形状不同）的数量](https://blog.csdn.net/weixin_44171872/article/details/109014435)

  ```C++
  class solution {
  public:
      int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1}; // 上下左右
      int numDistinctIslands(vector<vector<int>>& grid) {
          set<vector<int>> st; // 该set集合中的元素vector是某个岛屿相对其左上角的坐标
          for (int i = 0; i < grid.size(); i++) {
              for (int j = 0; j < grid[0].size(); j++) {
                  if (grid[i][j] == 1) { // 发现岛屿的左上角节点(i,j)
                      queue<int> q; // BFS用
                      vector<int> cur; // 存储当前岛屿相对于grid[i][j]的坐标
                      q.push(i);
                      q.push(j);
                      grid[i][j] = 0; // 标记
                      while (!q.empty()){
                          int x = q.front();
                          q.pop();
                          int y = q.front();
                          q.pop();
                          // 将偏移节点坐标插入cur
                          cur.push_back(x - i);
                          cur.push_back(y - j);
                          for (int k = 0; k < 4; k++) { // bfs遍历
                          	int ni = x + dx[k], nj = y + dy[k];
                          	if (ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size() && grid[ni][nj] == 1) {
                              	grid[ni][nj] == 0; // 标记
                                  q.push(ni);
                                  q.push(nj);
                          	}
                      	}
                      }
                      st.insert(cur); // 将当前岛屿的形状坐标vector插入set中，形状相同的岛屿vector<int> cur也相同，set会自动去重
                  }
              }
          }
          return st.size(); // set集合的大小就是不同形状岛屿的数量
      }
  }
  ```




---

### 其他



**虚拟化**可以将一台主机划分为多个操作系统，每个操作系统还有独立的cpu资源，存储资源，内存资源。充分的利用的硬件资源。我知道的虚拟化产品：vmware 、MS

常见的几种**dos攻击**

答：tcp syn泛洪 ，ping泛洪，udp泛洪等等

DNS劫持是什么？

>  DNS是指将网页域名翻译为对应的IP的一种方法。DNS劫持指攻击者篡改结果，使用户对域名的解析IP变成了另一个IP。

> 3.20深信服C++开发工程师电话面：
>
> 用过哪些redis数据结构（使用场景），查看端口号命令、 iptables，docker，讲一讲项目中遇到的困难（具体），怎么解决的，登录解密的密钥，分组加密，长连接：超时时间、真正的长连接、学习go和python

[**倒排索引(Inverted Index)**](https://blog.csdn.net/hguisu/article/details/7962350?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164791892916782089327763%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164791892916782089327763&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-7962350.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。

[面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

> 1. 排序链表
>
> 2. 对称与非对称加密算法的区别
>
> 3. TCP如何保证可靠性
>
> 4. 聊聊五种IO模型
>
>    5. hystrix 工作原理
>
> 5. 延时场景处理
>
> 6. https请求过程
>
> 7. **聊聊事务隔离级别，以及可重复读实现原理**
>
> 8. 聊聊索引在哪些场景下会失效？
>
> 9. 什么是虚拟内存
>
> 10. 排行榜的实现，比如高考成绩排序
>
> 11. 分布式锁实现
>
> 12. 聊聊零拷贝
>
> 13. 聊聊synchronized
>
> 14. 分布式ID生成方案



4.3计划

- [ ] 实验工件的设计

内存泄露与内存溢出的区别和联系

