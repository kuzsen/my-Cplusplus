

## 我的八股文

### 一、`STL`与常见数据结构与算法

> [STL总结与常见面试题](https://mp.weixin.qq.com/s/JWAestcpQTlp2fb1Q45AQg)
>
> [vector扩容原理说明](https://blog.csdn.net/yangshiziping/article/details/52550291)
>
> [c++vector容器的内存收缩和预留内存](https://blog.csdn.net/hacker_zrq/article/details/112849433)
>
> [c++11 之emplace_back 与 push_back的区别](https://ppipp.blog.csdn.net/article/details/84764104)
>
> [set和map区别](https://blog.csdn.net/lirui7610/article/details/79932949?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164931244516782184661859%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164931244516782184661859&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-79932949.142^v5^pc_search_result_cache,157^v4^control&utm_term=set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187)
>
> [红黑树与平衡二叉树的区别](https://blog.csdn.net/y506798278/article/details/104275033)
>
> [c++中map与unordered_map的区别](https://blog.csdn.net/zou_albert/article/details/106983268?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042694716780271939552%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165042694716780271939552&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106983268.142^v9^pc_search_result_control_group,157^v4^control&utm_term=c%2B%2Bunordered_map&spm=1018.2226.3001.4187)
>
> [哈希表的原理和使用](https://blog.csdn.net/weixin_38169413/article/details/81612307?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042689716782246411812%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165042689716782246411812&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-81612307.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8&spm=1018.2226.3001.4187)

#### 1.[10大排序](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)

[C语言实现排序算法+动图](https://mp.weixin.qq.com/s/eKU_DCU0tLwyqfVvRrSLMA)

在最坏的情况下，待排序的序列已经为正序或者逆序，快速排序的时间复杂度为`O(n^2)`

| 排序算法     | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       |
| :----------- | :------------- | :------------- | :--------- | :------------------- |
| 冒泡排序     | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| 选择排序     | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| 插入排序     | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| **快速排序** | O(n*log2n)     | O(n2)          | O(log2n)   | **不稳定**           |
| 堆排序       | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定               |
| 归并排序     | O(n*log2n)     | O(n*log2n)     | O(n)       | **稳定**             |
| 希尔排序     | O(n*log2n)     | O(n2)          | O(1)       | 不稳定               |
| 计数排序     | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 |
| 桶排序       | O(n)           | O(n)           | O(m)       | 稳定                 |
| 基数排序     | O(k*n)         | O(n2)          |            | 稳定                 |

#### 2.leetcode哪种题型比较深刻？

讲一下你在leetcode上刷题，对哪种题型或者哪道题印象比较深刻？

讲一下代码随想录的回溯5部曲、动态规划5步曲、二叉树（递归与迭代）、链表、字符串匹配、数组、图、滑动窗口、贪心算法

> 动态规划，Dynamic Programming，简称DP ，举例：左上角走到右下角最短路径
>
> 1. 确定dp数组（dp table）以及下标的含义
> 2. 确定递推公式
> 3. dp数组如何初始化(处理边界)
> 4. 确定遍历顺序
> 5. 举例推导dp数组  
> 6. 动态规划应该如何debug ：找问题的最好⽅式就是把dp数组打印出来，看看究竟是不是按照⾃⼰思路推导的！  

> 回溯算法
>
> 回溯法解决的问题都可以抽象为树形结构！
> 因为回溯法解决的都是在集合中递归查找⼦集， 集合的⼤⼩就构成了树的宽度，递归的深度，都构成的
> 树的深度。
> 递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）  
>
> ⼀般可以解决如下⼏种问题：
> 组合问题： N个数⾥⾯按⼀定规则找出k个数的集合
> 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
> ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
> 排列问题： N个数按⼀定规则全排列，有⼏种排列⽅式  
>
> 回溯三部曲
>
> - 回溯函数模板返回值以及参数  
>
> - 回溯函数终⽌条件  
>
> - 回溯搜索的遍历过程  
>
>   <img src="C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220405150012265.png" alt="image-20220405150012265" style="zoom: 67%;" />

#### 3.讲一下比较熟悉的stl数据结构和算法

数据结构讲`vector`，算法就讲`sort排序算法`、查找算法（二分）

> 是动态空间，随着元素的加⼊，它的内部机制会⾃⾏扩充空间以容纳新元素。 vector 维护的是⼀个连续的线性空间，⽽且普通指针就可以满⾜要求作为 vector 的迭代器（RandomAccessIterator）。查找性能好
>
> vector 的数据结构中其实就是三个迭 代器构成的，⼀个指向⽬前使⽤空间头的 iterator，⼀个指向⽬前使⽤空间尾的iterator，⼀个指向⽬前可⽤空间尾的 iterator。当有新的元素插⼊时，如果⽬前
>
> 容量够⽤则直接插⼊，如果容量不够，则容量扩充⾄两倍，如果两倍容量不⾜， 就扩张⾄⾜够⼤的容量。
> 扩充的过程并不是直接在原有空间后⾯追加容量，⽽是重新申请⼀块连续空间，将原有的数据拷⻉到新空间中，再释放原有空间，完成⼀次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效。  

or

> 1. vector底层是一个**动态数组**，包含**三个迭代器**，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。
>
> 2. 扩容：当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间**（1.5倍或者2倍）**，然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。
>
>    1. vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。
>
>    2. 为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。
>
> 3. 当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
>
>    [c++vector容器的内存收缩和预留内存](https://blog.csdn.net/hacker_zrq/article/details/112849433)
>
> 4. 迭代器失效，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了
>
> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/0m4YX595FokDvfsaYelz5KmLlWcvwqWZIvsAOuYciboO87Q7CA60g0oJk6rh1xeyK7zicETuE9MzH76icd1rLP5DA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

---

### 二、C++基础

#### 面向对象三大特征

>  1、继承： 
>
>    被继承的是父类（基类），继承出来的类是子类（派生类），子类拥有父类的所有的特性。 
>
> -  继承方式有公有继承、私有继承，保护继承。默认是私有继承 
>
>   - 公有继承`public`中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。 
>
>   -  私有继承`private`中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。 
>
>   - 保护继承`protect`中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。 
>
> - c++语言允许单继承和多继承
>
> -  优点：继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性； 
>
> - 缺点：继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现；父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为；如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性，最终限制了复用性。 
>
> - 虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。 
>
>  2、多态： 
>
>  多态性是指对不同类的对象发出相同的消息将会有不同的实现 
>
>  C++有两种多态，称为**动多态（运行期多态）和静多态（编译器多态）**，静多态主要是通过模板、重写来实现，而动多态是通过虚函数来实现的。即在基类中存在虚函数（一般为纯虚函数）子类通过重载这些接口，使用基类的指针或者引用指向子类的对象，就可以调用子类对应的函数，动多态的函数调用机制是执行器期才能确定的，所以他是动态的。 
>
>  优点：大大提高了代码的可复用性；提高了了代码的可维护性，可扩充性； 
>
>  缺点：易读性比较不好，调试比较困难；模板只能定义在头文件中，当工程大了后，编译时间十分的变态； 
>
>  3、封装： 
>
>  隐藏类的属性和实现细节，仅仅对外提供接口， 
>
>  封装性实际上是由编译器去识别关键字public、private和protected来实现的，体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。私有成员是在封装体内被隐藏的部分，只有类体内说明的函数(类的成员函数)才可以访问私有成员，而在类体外的函数时不能访问的，公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。 
>
>  优点：隔离变化；便于使用；提高重用性；提高安全性 
>
>  缺点：如果封装太多，影响效率；使用者不能知道代码具体实现。

#### 1. static

> 控制变量的存储方式和可见性。 
>
> (1)修饰局部变量
> 一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。
>
> (2)修饰全局变量
> 对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。
>
> 全局静态变量和局部静态变量的区别:
> 1.全局静态变量只能被当前源文件引用，不能被工程里其它源文件引用。除了这点特殊，其它与普通的全局变量一样。
> 2.局部静态变量，只执行一次初始化，只能被所在函数引用，函数执行完毕，变量仍存在，生存周期贯穿整个程序。
>
> (3)修饰函数
> 用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。
>
> (4)C++中的static
> ==如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的==

#### 2. const的含义及使用场景和作用

```C++
const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。
 
(1)const修饰基本数据类型

 1.const修饰一般常量及数组
  
 基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 
  
 2.const修饰指针变量*及引用变量&  
 
如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

(2)const应用到函数中,  

 1.作为参数的const修饰符
 
 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。
 [注意]：参数const通常用于参数为指针或引用的情况; 
 
 2.作为函数返回值的const修饰符
 
 声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。
(3)const在类中的用法

不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行
类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。

(4)const修饰类对象，定义常量对象 
常量对象只能调用常量函数，别的成员函数都不能调用。
```

#### 3. extern

```C++
在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

注意 extern 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
```

#### 4. define宏定义与内联函数

```c++
内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令
在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
内联函数有类型检测、语法判断等功能，而宏没有
内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样
  
内联函数适用场景:
使用宏定义的地方都可以使用 inline 函数。
作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。
    
```

#### 5.虚函数： 虚函数的作用和实现原理，什么是虚函数,有什么作用?

```c++
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。	
    
动态多态满足的条件：
1. 有继承关系
2. 子类重写父类的虚函数
3. 父类的指针或者引用,执行子类对象
	
虚函数实现原理:包括虚函数表、虚函数指针等 

虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。
```

**虚函数表存放位置？linux全局数据区，windows常量段**[C++中虚函数、虚指针和虚表详解](https://blog.csdn.net/qq_20817327/article/details/108859161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164760442916780271554589%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164760442916780271554589&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-108859161.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8&spm=1018.2226.3001.4187)

每个声明了虚函数或者继承了有虚函数的类，都会有一个自己的==虚函数表vtbl==。同时该类的每个对象都会包含一个==虚指针vptr==去指向该`vtbl`。虚函数按照其声明顺序放于 `vtbl` 表中, `vtbl` 数组中的每一个元素对应一个函数指针。如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置。在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中.

如果 `normalize()`是一个 `virtual member function`，那么调用：**`ptr->normalize();`**

实际上会被编译器转化为：**`(*ptr->vptr[1])(ptr);`**

- `vptr` 是指向虚函数表的指针
- `1` 是表中该函数的索引，
- `ptr` 表示的是`this`指针

一个类只有一个虚函数表，每个表中可能含有三种类型的虚函数：

- 此类定义的函数实例。包括重写了父类中的虚函数
- 从父类中继承的且没有重写的虚函数
- 纯虚函数

#### 6. **内联函数、构造函数、静态成员函数、模板函数可以是虚函数吗?**

对于虚函数有几点关键点：

- 虚函数是属于对象的
- 虚函数的和运行时期有关

由以上两点，可以回答原问题。

- `inline`：`inline` 需要在编译期就确定类的信息，但是虚函数具体是属于哪个类的，只有在动态运行时才能知道。
- `static`：静态函数是没有 `this` 指针，而虚函数是属于某个对象的`this`与`vptr`来调用的。
- `constructor`：虚函数等到运行时才知道是调用了哪个对象的虚函数。如果构造器也是虚函数，对象都无法构建。因此，构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被 `disable` 的。
- 模板函数 模板函数也不能是虚函数。因为，类会在`vtbl`中存放类中的所有的虚函数的函数指针，而一个模板函数如果设计为虚函数是无法获悉这个模板函数会被实例化为哪些具体的函数。

#### 7. **为什么需要虚析构函数，什么时候不需要? 父类的析构函数为什么要定义为虚函数**

- 一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是**为了当用一个基类的指针删除一个派生类的对象时， 派生类的析构函数会被正确调用**。
- 当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。 所以，**只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**

#### 8.纯虚函数，为什么需要纯虚函数？

```c++
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

virtual void funtion1()=0

原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)
纯虚函数不同的是父类绝对不能实现，且不能实例化，子类必须实现父类定义的虚函数接口，除非它也想成为抽象类，抽象类可以有部分方法实现，但至少要有一个纯虚函数的类才能叫抽象类。
Class B
{
public:
    virtual void fun1(){ cout << "fun1";} //虚函数，子类不用声明或实现
    virtual void fun2 = 0; //纯虚函数，子类必须声明并实现
};              
```

#### 9.[虚析构函数（√）、纯虚析构函数（√）、虚构造函数（X）](https://www.cnblogs.com/chio/archive/2007/09/10/888260.html)

#### 10. STL迭代器失效(拓跋阿秀八股)

> STL中迭代器失效的情况有哪些？
> **以vector为例：**
> 插入元素：
> 		1、尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
> 		2、中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size ==
> capacity时，所有迭代器均失效。
> 删除元素：
> 		1、尾后删除：只有尾迭代失效。
> 		2、中间删除：删除位置之后所有迭代失效。
> **deque 和 vector 的情况类似,**
> list双向链表每一个节点内存不连续, **删除节点仅当前迭代器失效**,erase返回下一个有效迭代器;
> map/set等关联容器底层是红黑树**删除节点不会影响其他**节点的迭代器, 使用递增方法获取下一个迭代器
> mmp.erase(iter++);
> unordered_(hash) 迭代器意义不大, **rehash之后, 迭代器应该也是全部失效**. 

#### 11.右值引用与move语义

- 左值和右值的区别

  > 如`int a = 5 中的变量是左值，5是右值  `；
  >
  > 左值就是有名字的变量（对象），左值必须要在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中有实体；可以被赋值，可以在多条语句中使用，比
  >
  > 而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值
  >
  >  一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址

- [一文读懂C++右值引用和std::move—————详细好文](https://zhuanlan.zhihu.com/p/335994370)

  - 本文非常值得读，细致
  - 在vector和string这个场景，加个`std::move`会调用到移动语义函数，避免了深拷贝，提升性能
  - **完美转发**，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换。std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。

- [c++ 之 std::move 原理实现与用法总结](https://ppipp.blog.csdn.net/article/details/84644069)

  - 在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是**将一个左值强制转化为右值引用，继而可以通过右值引用使用该值**，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);
  - C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
  - std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。原左lvalue值被moved from之后值被转移,所以变为空.

#### 12.数组vector与链表list的区别

- 为什么[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)比链表查询速度更快？
  - 数组由于是紧凑连续存储,可以随机访问，通过**索引**快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
  - 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。
- 数组(**顺序存储**)和链表（**链式存储**）有以下不同：
  - **数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。**
  - *存储形式**：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个节点要保存相邻结点指针；**
  - **数据**查找**：数组的**线性查找速度快，查找操作直接使用偏移地址**。链表需要**按顺序检索结点**，效率低；**
  - **数据**插入或删除**：链表可以快速插入和删除结点，而数组则可能需要大量数据移动；**
  - 越界问题**：链表不存在越界问题，数组有越界问题。

#### 13.常量指针和指针常量的区别：

> const pointer，指针本身是一个常量，指向的地址不能改变，里面的内容可以修改。（门牌号11，不管里面住谁，我指向的都是这条街11号）
> pointer to const，指向的内容是一个常量，可以改变指向的地址，只要新地址里面也是常量就好。（小明原来住在六舍356，后来搬到357，不管是356还是357，里面住的都是小明）
>
> 当然如果单纯为了区别两个中文，那么const=常量，*=指针，看谁在谁前面就叫对应的名字。

#### 14.[c语言如何实现多态](https://blog.csdn.net/wenqiang1208/article/details/76244628)

#### 15.介绍c语言指针

<img src="https://img-blog.csdnimg.cn/20200511093640946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIxNzU3Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" />

1. 指针的定义：指针是一个变量，用来存放地址的变量
2. 指针的类型：
   - 基本类型：int 、short、long、float 、double、char
     如 int *p；//表示定义一个指针，这个指针指向整形变量，这个指针将存放的是整形变量的地址。*
   - **数组指针：**指针指向一个数组
     `int (*a) [10]`表示指针a指向一个int型的长度为10的数组
   - **函数指针：**指针指向一个函数
     `void (*a) ();`/表示指针指向一个无参数无返回值的函数
3. 指针的引用：指针引用后得到的是该地址所对应的变量的值。
4. 二级指针：指向一级指针地址的指针
5. 指针的运算：
   - 指针`+`或者`-`一个数，表示指针加减这个数的类型所占内存的整数倍
     如` int *p=a;p=p+2;` , 在VC6.0里面，实际上p加了2 * 4=8
   - 指针减去一个指针，表示**两个指针之间所差的内存单元或者元素个数**，两个指针相加没有意义
   - 关系运算，如果定义了两个指针变量p和q，并且都已经初始化了，
     - 如果`p==q`，则表示p和q指向同一个地址
     - `p>q`,则表示p指向高地址而q指向低地址
     - 也经常拿`p和NULL`做比较，用来表示指针当前的状态，这在数据结构中应用非常广泛，比如说链表节点的查找、判断是否为空等等
6. 指针和数组的关系：
   指针和数组关系密切，数组可以通过指针去引用，数组可以存放指针，数组也可以由指针去访问，指针也能存放数组的地址

#### 16.this指针是什么？调用函数的过程？

[C++ this指针详解（精辟） (biancheng.net)](http://c.biancheng.net/view/2226.html)

> this 是 [C++](http://c.biancheng.net/cplus/) 中的一个关键字，也是一个 const [指针](http://c.biancheng.net/c/80/)，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址，它指向当前对象，通过它`->`可以访问当前对象的所有成员。this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。
>
> - this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
>
> - **this****指针是什么时候创建的？****this****在成员函数的开始前构造，在成员函数的结束后清除**
>
> - this 到底是什么
>
>   this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
>
>   this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。
>
>   在《[C++函数编译原理和成员函数的实现](http://c.biancheng.net/view/vip_2220.html)》一节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。
>
> - 所谓当前对象，是指正在使用的对象。例如对于`stu.show();`，stu 就是当前对象，this 就指向 stu。
> - 类中`成员函数的参数`和`成员变量重名`时，只能通过 this 区分;
> - 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this
> - **this**指针存放在何处？this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。
> - 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用**，因为==如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的==
> - 

[C++中this指针的用法详解 - 优秀afa - 博客园 (cnblogs.com)————好文章](https://www.cnblogs.com/zhengfa-af/p/8082959.html)



#### 17.智能指针`share_ptr`怎么实现的？是线程安全的吗？

1. 首先说一下为什么使用智能指针？

   > **智能指针是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的**  
   >
   > 智能指针其作⽤是管理⼀个指针，避免咱们程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。
   >
   > **因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。**   

2. `shared_ptr`的实现机制是**==在拷⻉构造时使⽤同⼀份引⽤计数==**  

   > （1）⼀个模板指针`T* _ptr`，指向实际的对象
   > （2）⼀个引⽤次数
   >           必须new出来的，不然会多个shared_ptr⾥⾯会有不同的引⽤次数⽽导致多次delete
   > （3）重载operator*和operator->
   >           使得能像指针⼀样使⽤shared_ptr
   > （4）重载copy constructor
   >           使其引⽤次数加⼀（拷⻉构造函数)
   > （5）重载operator=（赋值运算符）
   >           比如将b赋值给a，如果原来的shared_ptr a已经有对象，在赋值操作执行则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象引⽤次数加⼀
   > （6）重载析构函数
   >           使引⽤次数减⼀并判断引⽤是否为零; (是否调⽤delete)  

3. `shared_ptr`的线程安全问题

   >（1）同⼀个shared_ptr被多个线程“读”是安全的;
   >（2）同⼀个shared_ptr被多个线程“写”是不安全的;
   >证明：在多个线程中同时对⼀个shared_ptr循环执⾏两遍swap。 shared_ptr的swap函数的作⽤就是和另外⼀个shared_ptr交换引⽤对象和引⽤计数，是写操作。执⾏两遍swap之后, shared_ptr引⽤的对象的值应该不变）
   >（3）共享**引⽤计数的不同**的shared_ptr被多个线程”写“ 是安全的  

```c++
template<typename T>
class SharedPtr
{
private:
    T* _ptr; // (1)
    int* _pcount; // 指向引用计数的指针
public:
    // 初始化构造函数（有参数）
    SharedPtr(T* ptr == NULL): _ptr(ptr), _pcount(new int(1)) {}; // 初始化列表构造函数？
    // (3)
    T& opertor*() { // 返回智能指针this维护的指针_ptr指向的实际对象
        return *(this->_ptr);
    }
    T* opertor->() { // 返回该智能指针this中维护的指针_ptr
        return this->_ptr;
    }
    // (4)拷贝构造函数
    SharedPtr(const SharedPtr& s): _ptr(s._ptr), _pcount(s._pcount) {
        (*_pcount)++; // 当前对象的引用计数加一
    }
    // (5)重载=
    SharedPtr<T>& opertor=(const SharedPtr& s) {
        if (this != &s) {
            if (--(*(this->_pcount)) == 0) {
                delete this->_ptr;
                delete this->_pcount;
            }
            _ptr = s._ptr;
            _pcount = s._pcount;
            *(_pcount)++;
        }
        return *this;
    }
    // (6)
    ~SharedPtr() {
        --(*(this->_pcount) == 0) {
            delete _ptr;
            _ptr = NULL;
            delete _pcount;
            _pcount = NULL;
        }
    }
}
```



#### 18.[内存泄露和内存溢出的区别和联系及产生原因](https://www.cnblogs.com/pan-louis/p/10768340.html)

一、什么是[内存溢出](https://so.csdn.net/so/search?q=内存溢出&spm=1001.2101.3001.7020)和内存泄露

1、内存泄漏（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。
2、内存溢出 （out of memory）：:指程序申请内存时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。也就是说给你个int类型的存储数据大小的空间，但是却存储一个long类型的数据，这样就会导致内存溢出。
二、内存溢出和[内存泄露](https://so.csdn.net/so/search?q=内存泄露&spm=1001.2101.3001.7020)的关系以及区别

1.关系：**内存泄露最终会导致内存溢出**，由于系统中的内存是有限的，如果过度占用资源而不及时释放，最后会导致内存不足，从而无法给所需要存储的数据提供足够的内存，从而导致内存溢出。导致内存溢出也可能是由于在给数据分配大小时没有根据实际要求分配，最后导致分配的内存无法满足数据的需求，从而导致内存溢出。

2.区别：内存泄露是由于GC无法及时或者无法识别可以回收的数据进行及时的回收，导致内存的浪费；内存溢出是由于数据所需要的内存无法得到满足，导致数据无法正常存储到内存中。内存泄露的多次表现就是会导致内存溢出。

> 内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越长，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。
>
> ==内存泄漏的分类==
>
> （1）堆内存泄漏 （Heap leak）
> 对内存指的是程序运⾏中根据需要分配通过malloc,realloc new等从堆中分配的⼀块内存，再是完成后必须通过调⽤对应的 free或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使⽤，就会产⽣ Heap Leak.
> （2）系统资源泄露（Resource Leak）
> 主要指程序使⽤系统分配的资源⽐如 Bitmap,handle ,SOCKET 等没有使⽤相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运⾏不稳定。
> （3）没有将基类的析构函数定义为虚函数
> 当基类指针指向⼦类对象时，如果基类的析构函数不是 virtual，那么⼦类的析构函数将不会被调⽤，⼦类的资源没有正确是释放，因此造成内存泄露。  

> ==避免内存泄露的几种方式==
>
> （1）使用智能指针，是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的  
>
> （2）计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如
> 果不为0则表示存在内存泄露
>
> （3）一定要将基类的析构函数声明为虚函数
> （4）对象数组的释放一定要用delete []
> （5）有new就有delete，有malloc就有free，保证它们一定成对出现  

> ==如何检测内存泄漏==
> （1）⾸先可以通过观察猜测是否可能发⽣内存泄漏， Linux 中使⽤` swap 命令`观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
> （2）还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 `netstat、 vmstat` 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
> （3）当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 ，`Linux下可以使用Valgrind工具，Windows下可以使用CRT库 `

#### 19.什么情况下堆栈会溢出?

>  1.**函数调用层次太深**。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，`当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址`而造成栈溢出。 
>
>  2.**动态申请空间使用之后没有释放**。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。 
>
>  3.**数组访问越界**。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。 
>
>  4.**指针非法访问**。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误

#### 20. C++ 中内存分配情况
> 问：在函数体内部创建的变量存放在什么位置？
>
> 答：一般的局部变量放在栈区，new/malloc创建的对象放在堆区，static修饰的变量放在全局静态区
>
> 
>
> **栈**：由编译器管理分配和回收，存放局部变量和函数参数。
> **堆**：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。
> **全局/静态存储区**：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。
> **常量存储区**：存储常量，⼀般不允许修改。
> **代码区**：存放程序的⼆进制代码  

#### 21.sizeof

[C++ sizeof 详解](https://blog.csdn.net/MARSHCW/article/details/110306025?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042644816780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042644816780274146896&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-110306025.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%B8%B8%E8%A7%81sizeof&spm=1018.2226.3001.4187)

[sizeof与strlen的比较](https://blog.csdn.net/liitdar/article/details/81777539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042644816780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042644816780274146896&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-81777539.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%B8%B8%E8%A7%81sizeof&spm=1018.2226.3001.4187)

[常见面试题总结之C++中sizeof问题](https://blog.csdn.net/u013050857/article/details/70820935?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042644816780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042644816780274146896&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-70820935.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%B8%B8%E8%A7%81sizeof&spm=1018.2226.3001.4187)

>- 定义：*sizeof*是一个操作符（*operator*）。其作用是返回一个对象或类型所占的内存字节数。其返回值类型为`*size_t*`。（*size_t*在头文件`*stddef.h*`中定义，它依赖于编译系统的值，一般定义为 *typedef unsigned int size_t;*）
>
>- ==数据类型的sizeof:==
>
>  | int  | short | float | bool | double | char | 指针*                                                       |
>  | ---- | ----- | ----- | ---- | ------ | :--- | ----------------------------------------------------------- |
>  | 4    | 2     | 8     | 1    | 8      | 1    | 4（32位）指针变量的*sizeof*值与指针所指的对象没有任何关系。 |
>
>- 数组的*sizeof*值等于数组所占用的内存字节数。
>
>  注意：*1*）当字符数组表示字符串时，其*sizeof*值将*’/0’*计算进去。
>
>  ​     	  *2*）当数组为形参时，其*sizeof*值相当于指针的*sizeof*值。
>
>- ==结构体struct的sizeof==
>
>  - 涉及到字节对齐问题：算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了；
>
>  - 字节对齐的细节和编译器的实现相关，但一般而言，满足三个准则：
>
>    - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
>
>    - 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；
>
>    - 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）
>
>    - ```c++
>      struct st{
>          char a;     //size=1 + 对界偏移为7
>          double b;   //size=8
>          int c;      //size=4
>          char d;     //size=1+对界偏移为3 
>      }; //最后输出为1+7+8+4+1+3=24
>      
>      
>      class A{
>      public:
>           int a;//4
>           char b;//1+3
>       };
>       class B:public A{  // B继承A，sizeof(B)=1+3+4+1+3=12
>       public:
>           char c;
>       };
>      ```
>
>  - 空结构体（不含数据成员）的*sizeof*值为*1*。试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。
>
>- ==联合体`Union`的sizeof==
>
>  - 结构体在内存组织上是顺序式的，联合体则是重叠式，各成员共享一段内存；所以整个联合体的*sizeof*也就是每个成员*sizeof*的最大值。
>
>  - union sizeof计算规则:sizeof(union)=最宽基本成员变量的字节数
>
>  - ```c++
>    union uu{
>    	    int i;
>    	    char c;
>    	};//最后输出为4，因为最大字节为int的4字节
>    ```
>
>- ==string的sizeof==
>
>  - sizeof(string)大小不一定，字符串所占的空间是从堆中动态分配的
>  - 1、sizeof()返回的是string对象所占用的空间，而不是string所存储的字符串的大小。
>    2、string的实现在各库中可能有所不同，但是在同一库中相同的一点是，无论string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。   
>    3、sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现，VC6.0测试后sizeof(string)=16，说明还是跟编译器有关。
>
>- ==函数的sizeof==
>
>  - sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。
>
>  - 对函数求值的形式：sizeof(函数名(实参表))
>
>    注意：1）不可以对返回值类型为空的函数求值。 
>
>       		2）不可以对函数名求值。
>
>    ​           *3*）对有参数的函数，在用*sizeof*时，须写上实参表
>
>- ==sizeof与strlen的比较==
>
>  - sizeof 是 C++ 编程语言的一个运算符，而 strlen 是一个函数（头文件为 string.h）；
>  - sizeof 的操作对象（即操作数 operand）可以是数组、指针、类型、对象、函数等，而 strlen 的参数为字符型指针“const char * str”，当数组名作为 strlen 函数参数时，实际上在函数执行时该数组就退化成指针了；
>  - sizeof 与 strlen 的返回值类型均为 size_t（即 unsigned int）；
>  - sizeof 的值在编译的时候已经计算好了，而 strlen 是在运行时才计算的。由于是在编译时计算，因此 sizeof 不能用来计算动态分配的内存空间的大小，实际上，使用 sizeof 计算操作数（operand）的大小，其返回值跟操作数存储的内容无关；
>  - strlen 函数实际完成的功能是从 str 字符串的第一个地址开始遍历，直到遇到结束符 NULL（'\0'）。需要注意，strlen 返回的字符串长度大小不包括 NULL（'\0'）；
>
>- 常见的一个面试题
>
>  > 【HR】：定义一个空的类型，里面没有任何成员变量和成员函数，对该类型求sizeof得到结果是多少？
>  >
>  > 【acmer】：答案是1。
>  >
>  > 
>  >
>  > 【HR】：为什么不是0？
>  >
>  > 【acmer】：空类型的实例中不包括任何信息，本来求sizeof得到0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则则无法使用这些实例，至于占用多少内存，由编译器决定，Visual Studio 中每个空类型的实例占用1字节的空间。
>  >
>  > 
>  >
>  > 【HR】：如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到结果又是多少？
>  >
>  > 【acmer】：和前面一样，还是1.调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的类型只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数在实例内添加任何额外的信息。
>  >
>  > 
>  >
>  > 【HR】：那如果把析构函数标记为虚函数呢？
>  >
>  > 【acmer】：C++的编译器一旦发现一个类型中有虚拟函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，在32位的机器上，一个指针占4字节的空间，因此求sizeof得到4；在64位机器上，一个指针占8字节的空间，因此求sizeof得到8。

#### 22.C++多线程

[C++11 多线程（std::thread）详解](https://blog.csdn.net/sjc_0910/article/details/118861539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165046387516782089343670%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165046387516782089343670&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-118861539.142^v9^pc_search_result_control_group,157^v4^control&utm_term=c%2B%2B%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4187)



---



### 三、项目

> [什么是彩虹表？——好文章](https://blog.csdn.net/nie19940803/article/details/76641498)
>
> [RSA加密算法原理](https://blog.csdn.net/a745233700/article/details/102341542?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5.pc_relevant_default&utm_relevant_index=8)————详细介绍RSA非对称加密算法
>
> [密码泄漏，不可小视——解决方案](https://mp.weixin.qq.com/s/nG2HjpXJQqRtZ3joRrUleQ)

#### 1. 服务器端实现高并发——项目设计

1. TCP`socket,bind,listen...`+多线程

   - 优点：代码简单，结构清晰，把各种功能的业务代码放到线程函数里
   - 缺点：对服务器性能要求比较高，比如，虚拟机（1G内存，单核CPU，大概能够接受300个这种结构客户端的请求，如果再多，服务器创建线程时报错：内存不够）
   - 多线程只有在多核CPU上，才能体现出真正的并发优势，我们使用的阿里云轻量服务器是单核的，单核CPU使用多线程是一种伪并发，线程之间切换也需要时间
   - 综上：效率不高

2. select：文件描述符（对应一个客户端）的集合，单线程循环，对服务器性能要求相对较低，但是并发量有限（1024），处理效率低，一旦有数据可读的时候，需要循环遍历整个集合

3. epoll：对服务器性能要求相对较低，理论上并发量无限（资源毕竟有限，终将会消耗完），处理效率高，一旦有数据可读的时候，自己`epoll_event`事件结构体会直接跳出来，但是，缺点：同步（某个客户端的请求处理比较麻烦耗时，那么其他客户端在此期间的请求会监听不到）

4. epoll+多线程：解决3的缺点，epoll监听到某个客户端请求，启动一个线程，把他教给线程去处理，epoll本身继续执行监听任务，缺点：频繁启动线程，浪费时间和资源

5. epoll+线程池：解决4缺点，线程池是在服务器空闲的时候提前建立大量的线程，等待使用，处理完某个客户端请求之后，再把线程放回到线程池中

6. libevent（底层封装了epoll），集合中的事件不同于epoll中的epoll_event，叫做`buffer_event`，还封装了`TCP中的各种函数`，稳定；既然是封装了epoll，也是一种同步方式

7. ==本项目==：libevent+多线程，但是不同于4，因为`libevent`也是不允许多个线程同时操作事件集合`event_base`，涉及到同步问题，而且高并发下，多线程将资源会耗尽

   所以管理线程（监听），处理客户端请求时，新建工作线程（在这个里面再创建一个事件集合，）

   一个线程中只有一个事件，没有体现出libevent事件集合的优势

==**最好的实现方案设计：**==

- 聊天等功能时，使用`libevent+单线程`，因为聊天等功能都比较简单，不会很时，造成单线程的堵塞问题，且单线程下使用io多路复用可以处理高并发的聊天请求
- 传输文件功能时，再启用额外的线程，处理这种比较耗时的工作

#### 2.说一下项目的难点

> 1. 考虑使用**多线程**解决高并发下处理用户请求、发送文件可能造成的堵塞，与单线程io多路复用文件发送依然会造成堵塞，影响用户在此期间的聊天功能
> 2. 实现登录功能时用户密码的加密问题
>    - 直接存储原密码，很容易泄露造成安全问题
>    - md5，使用某种哈希函数对原密码加密
>    - 一种**[彩虹表算法](https://blog.csdn.net/nie19940803/article/details/76641498)**专门用来破解哈希加密
>    - 防御彩虹表的一种方法是提高hash函数的计算难度，但是提高单次hash的计算难度有违hash的设计初衷。因此常见的方法是对特定的密码做大量反复的hash操作。例如将H定义为计算一千次MD5后的结果。这样的话，每个彩虹表项将对应1000个hash值和一个合法密码，这样的话彩虹表的k值不能取得太大，否则无法再可接受的时间内完成破解，而如果将k值取值减小，又大大的增加了彩虹表的空间。从而提高破解的成本。
>    - 综上，我才用==加盐`salt`+哈希函数加密==，防御彩虹表的破解
>      - 加盐是指通过在密码任意固定位置插入特定的字符串，让[散列](https://so.csdn.net/so/search?q=散列&spm=1001.2101.3001.7020)后的结果和使用原始密码的散列结果不相符
>      - 因此即使通过彩虹表找到了特定hash值对应的密码，也无法得到用户输入的密码，甚至根本得不到密码
>      - 即使破解者知道盐值和插入位置，也需要针对加盐的hash函数做对应的R函数修改，因此已有的彩虹表数据就完全无法使用，必须针对特定的H重新生成，这样就**提高了破解的难度**。

#### 3. 任意hash函数应具备的特点

> 1.      压缩性：对于任意给定输入有唯一特定长度输出，例SHA1的hash值为20字节。
>2.      容易计算：即从原始数据计算hash值应该很容易。
> 3.      抗修改：对原始数据哪怕1bit的修改都会对hash值产生重大影响。
>4.      抗碰撞：这里分为强碰撞和弱碰撞，弱碰撞是给定一个数据很难找出相同hash值得另外一个数据。强碰撞是很难找出hash值相同的两个数据。
> 4.      单向性：即根据散列后hash值推断出原始输入值是很难的

#### 4. libevent介绍

> 常见的I/O编程框架：
>
> 对比几个常见的I/O编程框架：libevent，libev，libuv，aio，boost.Asio。
>
> libevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。
> 设计模式 ：libevent为Reactor模式；
> 层次架构：livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务；
> 可移植性 ：libevent主要支持linux平台，freebsd平台，其他平台下通过select模型进行支持，效率不是太高；
> **事件分派处理 ：libevent基于注册的事件回调函数来实现事件分发**；
> 涉及范围 ：libevent只提供了简单的网络API的封装，线程池，内存池，递归锁等均需要自己实现；
> 线程调度 ：libevent的线程调度需要自己来注册不同的事件句柄；
> 发布方式 ：libevent为开源免费的，一般编译为静态库进行使用；
> 开发难度 ：基于libevent开发应用，相对容易，具体可以参考memcached这个开源的应用，里面使用了 libevent这个库。

---

### 四、计算机网络

> [计算机网络经典20问！](https://mp.weixin.qq.com/s/NCXN2iW_DpEHEiePDP7Yhg)
>
> [`http`面试问题集锦](https://www.cnblogs.com/rachelxiao/p/12423095.html )`http header`有什么内容
>
> [看一遍就理解：IO模型详解](https://mp.weixin.qq.com/s/bb7C6VNbq7REP9u8PsreSg)



#### OSI 的七层模型分别是？各自的功能是什么？

> [帅地玩编程网站版本](https://www.iamshuaidi.com/3612.html)
>
> 以下是小贺八股文版本
>
> ![image-20220709104746158](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709104746158.png)
>
> 

#### 简单说一下每层对应的网络协议有哪些》

<img src="https://image.iamshuaidi.com/picture/image-20210607144015234.png" alt="img" style="zoom: 67%;" />

#### TCP头部中包含哪些信息？

![图片](https://mmbiz.qpic.cn/mmbiz_png/g6WfVFoiaM5RDBxVUE6n2IgQTbicicPK9dzm9X0k1tb2GacJ6JqavsG6y7nCficnJxl850RE4WdDLpGRZufagaSp1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![image-20220709105918291](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709105918291.png)

#### **http请求报文的请求头中一般有什么？**

> 1）**Accept** 作用： 浏览器端可以接受的媒体类型 例：Accept ：text/html 
>
> 2）**Accept-Encoding**： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
>
> 3）**Accept-Language** 作用： 浏览器申明自己接收的语言。 例：Accept-Language: en-us
>
> 4）**Connection** 例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
>
> 5）**Host**（发送请求时，该报头域是必需的） **作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的**
>
> 6）Referer 作用：当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的
>
> 7）**User-Agent 作用：告诉HTTP服务器， 客户端使用的[操作系统](http://lib.csdn.net/base/operatingsystem)和浏览器的名称和版本**.





#### **http缓存机制是怎样的，如何合理地缓存http？**

> ==Http缓存主要分为两种：强缓存和协商缓存==
>
> 1）**强缓存基本原理是：所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据**。
>
> Expire 其指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的。但是它本身是一个HTTP1.0标准下的字段，所以如果请求中还有一个置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么 Expires 头就会被忽略。
>
> Cache-Control通用消息头用于在http 请求和响应中通过指定指令来实现缓存机制。其常用的几个取值有：
>
> private：客户端可以缓存
>
> public：客户端和代理服务器都可以缓存
>
> max-age=xxx：缓存的内容将在xxx 秒后失效
>
> s-max-age=xxx：同s-max-age，但仅适用于共享缓存(比如各个代理)，并且私有缓存中忽略。
>
> no-cache：需要使用协商缓存来验证缓存数据
>
> no-store：所有内容都不会缓存，强缓存和协商缓存都不会触发
>
> ==must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。==
>
> 2**）当强缓存过期未命中或者响应报文Cache-Control中有must-revalidate标识必须每次请求验证资源的状态时，便使用协商缓存的方式去处理缓存文件。**
>
> **协商缓存主要原理是从缓存数据库中取出缓存的标识，然后向浏览器发送请求验证请求的数据是否已经更新，如果已更新则返回新的数据，若未更新则使用缓存数据库中的缓存数据**

#### [TCP粘包问题](https://blog.csdn.net/weixin_41047704/article/details/85340311?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&utm_relevant_index=12)

>  “粘包问题”的概念用一句话说：就是，不同结构的多个包合成了一个大包，从而不知道怎么去把这个大包分割出原来的包。
>
> 解决方式：
>
> 1. **格式化数据：每条数据有固定的格式（开始符，结束符）**，这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
> 2. 发送长度：**发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度**，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

#### **TCP如何保证可靠性**

- 首先，TCP的连接是==基于三次握手，而断开则是四次挥手。确保连接和断开的可靠性==。
- 其次，TCP的可靠性，还体现在==有状态==;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在==可控制==。它有==报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制==。



#### TCP流量控制——by滑动窗口

![image-20220709111410740](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709111410740.png)

#### 拥塞控制算法

TCP四大拥塞控制算法总结？（极其重要）  ——————拓跋阿秀的八股文

![image-20220709120547125](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709120547125.png)

[《计算机网络》学习笔记 NO.029 TCP协议的拥塞控制](https://mp.weixin.qq.com/s/rqyc8zaW-7-pFTjO-N3p3A)

1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速恢复

#### 如何区分流量控制和拥塞控制？

- 流量控制**属于通信双⽅协商**；拥塞控制涉及通信链路全局，拥塞控制是个庞大的问题，因为考虑到了整个网络。对于拥塞控制很难有最优解
- 大小————流量控制需要通信双⽅各维护⼀个发送窗、⼀个接收窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化**由试探性发送⼀定数据量数据探查⽹络状况后⽽⾃适应调整**。
- **实际最终发送窗⼝ = min{流控发送窗⼝，拥塞窗⼝}**  

#### 解释一下超时重传和快速重传的区别——拓跋阿秀八股文

> ==超时重传==TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止 .
>
> 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做==快速重传==，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。  
>
> 超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：
>
> 1. 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.
> 2. cwnd重置为1
> 3. 进入慢启动过程
>
> 最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递  

> 所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：
>
> 1. cwnd大小缩小为当前的一半
> 2. ssthresh设置为缩小后的cwnd大小
> 3. 然后进入快速恢复算法Fast Recovery。  



#### 快速重传为什么是3次ack以后才开始

- 主要是为了区分包的丢失，是由什么原因引起的
  - 1、包checksum出错
  - 2、网络拥塞
  - 3、网路断
- 如果在反向还可以接受到发送数据包的ack，可以认为网络没有断，否则也收不到ack，排除3
- 如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作  
- 如果接收到三个或三个以上的duplicated ACK，则大概率是丢包  ，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，说明先前的发送的包出错了，则一切OK，流速依然。  而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理  

#### 在浏览器中输入**url**地址后显示主页的过程?  

- 根据域名，进行**DNS域名解析**；
- 拿到解析的IP地址，建立TCP连接；  
- 向IP地址，发送HTTP请求；
- 服务器处理请求；
- 返回响应结果；
- 关闭TCP连接；
- 浏览器解析HTML；浏览器布局渲染；  

#### DNS域名解析过程

（找到客户端发起的某个web服务器（域名：www.baidu.com）对应的IP地址)

浏览器的缓存——>系统hosts文件——>本地DNS服务器——>根域名服务器——>顶级域名服务器——>权限域名服务器。

> 1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器
>
> 2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找
>
> 3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器
>
> 4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址
>
> 5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器
>
> 6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息
>
> 7、客户机的本地的dns服务器会将查询结果返回给我们的客户机
>
> 8、客户机根据得到的ip信息访问目标主机，完成解析过程

两种查询方式：==微信收藏文章看图片==

递归查询：本地域名服务器作为DNS客户端的身份，递归的方式向其他更高级别的域名服务器进行递归查询，代替主机/客户端查询

迭代查询：当根域名服务器x本地服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该找哪个域名服务器y进行查询，然后本地服务器向y进行相同方式的迭代查询

#### **SYN攻击是什么？**

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间**占用未连接队列**，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
==检测 SYN 攻击==非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基
本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击  。

`netstats -n -p TCP | grep SYN_RECV`

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

==优化方式：==

1. 缩短SYN Timeout时间
2. 记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。

#### **为什么https更加安全，ssl加密是怎样的？**

>  http是直接和tcp通信，https=http+ssl加密；ssl加密：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。



#### HTTPS的连接过程

> 1. 浏览器将支持的加密算法信息发给服务器
> 2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
> 3. ==客户端(SSL/TLS)解析证书验证证书合法性==，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
> 4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
> 5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
> 6. 服务器将加密后的密文发送给客户端
> 7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

#### HTTPS客户端验证CA机构颁发给服务器的数字证书过程

> 1. 什么是数字证书？
>
>    - 服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：**证书内容、证书签名算法和签名**，签名是为了验证身份。
>
>    - **数字签名的制作过程**：
>      1. CA使用证书签名算法对证书内容进行**hash运算**。
>      2. 对hash后的值**用CA的私钥加密**，得到数字签名。
>
> 2. 服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站
>
> 3. **浏览器验证过程**：
>
>    1. 获取证书，得到证书内容、证书签名算法和数字签名。
>    2. 用CA机构的公钥**对数字签名解密**（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。
>    3. 用证书里的签名算法**对证书内容进行hash运算**。
>    4. 比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。

#### 常用对称与非对称加密算法有哪些

先复习一下相关概念：

> - 明文：指没有经过加密的信息/数据。
> - 密文：明文被加密算法加密之后，会变成密文，以确保数据安全。
> - 密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。
> - 加密：将明文变成密文的过程。
> - 解密：将密文还原为明文的过程。

对称加密算法:加密和解密使用**相同密钥**的加密算法。常见的对称加密算法有**AES、3DES、DES、RC5、RC6**等。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmRWNuUibfyQusbEibTQ1kuW4Bl7e4x0g9ra3KVjJCWFpiaKtcVH6ZxpKRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**非对称加密算法**：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。主要的非对称加密算法有：**[RSA](https://blog.csdn.net/a745233700/article/details/102341542)、Elgamal、DSA、D-H、ECC**。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmQWfgJ9BeRH1f0CPUhhTBO7POHoLwwUibkjdLwepWkgFCP0kNXpSwm9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

#### [ARP与RARP协议](https://blog.csdn.net/dan15188387481/article/details/49823729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164896958216782092956115%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164896958216782092956115&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-49823729.142^v5^pc_search_result_cache,157^v4^control&utm_term=ARP%E4%B8%8ERARP%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187)

> 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，
> 并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议
> 是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击
> 者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地
> 址的对应关系、添加或删除静态对应关系等。
>
> arp解析过程：
> 1.若A要知道B的mac地址，先判断自己的rap缓冲区中是否有B的ip和mac的映射，如果有，则直接得到B的mac地址，若没有，则发送rap广播请求包给该网络上的所有主机
> 2.该网络上所有主机收到请求包后打开传给自己的上层----网络层，网络层判断是否是给自己的信息（判断数据包中的目的IP是否和自己的IP一样），若不是，则丢弃，若是（也就是B收到了），则将A的amc地址填充到自己的arp缓冲区中（方便下次使用），并将自己的mac地址填充到响应包中发送给A
> 3.A收到响应包后就知道了B的mac地址，然后将这个mac地址填充到自己的arp缓冲区中
> 此外，若该网络中不存在B，即地址不可达，则A会收到一个地址不可达的ICMP包。ICMP（Internet控制报文协议）工作在网络层，用于传递差错信息，时间，回显等控制数据。
>
> 教材上把ARP协议划到网络层，是因为ARP协议属于TCP/IP协议簇。在TCP/IP模型中，它所有定义的协议是在网际层上的。
>
> 再看按照OSI的标准，数据在传递时每层会加上自己的信息。当网络层的IP包进入链路层时，链路层通过ARP协议添加链路信息，而这不是网络层的功能。
>
> 所以有很多人说ARP是链路层的。
>
> 可以这样做，在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。
>
> 考试我们要按教材做，接网络层。



<img src="https://img-blog.csdnimg.cn/20191019105720115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcnRfX19fMzM5,size_10,color_FFFFFF,t_70" alt="img" style="zoom:33%;" />

#### `ping baidu.com`发生了什么

> 1、首先进行DNS域名解析得到目标主机对应的ip地址
>
> - 主机查找本地系统Hosts文件的DNS缓存，如果存在www.baidu.com对应的IP,则获取IP；
> - 若本地系统没有对应IP，主机操作系统生成一个DNS查询报文，将[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)www.baidu.com放入DNS报文段中，进行DNS域名解析

> 2、`ping`过程：
>
> - `ping`命令的作用和原理
>   - 「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。
>   - ping 命令是基于` ICMP 协议`来工作的，`ICMP协议`是`“Internet Control Message Protocol”（因特网控制消息协议）`的缩写。它是`TCP/IP协议族`的一个子协议，用于在`IP主机、路由器`之间传递控制消息。`ping 命令`会发送一份`ICMP回显请求报文`给目标主机，并等待目标主机返回`ICMP回显应答`。因为`ICMP协议`会要求目标主机在收到消息之后，必须返回`ICMP应答消息`给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。
>   - [补充：什么是`ICMP`？](https://smile.blog.csdn.net/article/details/82782962)
>
> - 举一个例子来描述**「ping」命令的工作过程**：
>
> 1. 假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2
> 2. 此时，ping命令会在主机A上**构建一个 ICMP的请求数据包**（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。
> 3. IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，**构建成一个IP数据包**。
> 4. IP数据包构建完成后，还不够，还需要**加上MAC地址**，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并**交给数据链路层，组装成一个数据帧**，依据以太网的介质访问规则，将它们传送出出去。
> 5. 当主机B收到这个数据帧之后，会**首先检查它的目标MAC地址是不是本机**，**如果是就接收下来处理**，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会**构建一个ICMP应答数据包，回发给主机A**
> 6. **在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达**。**除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。**

#### [udp如何实现可靠传输](https://www.cnblogs.com/williamjie/p/11133180.html)

> UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。
>
> 传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
>
> 最简单的方式是**在应用层模仿传输层TCP的可靠性传输**。下面不考虑拥塞处理，可靠UDP的简单设计。
>
> - 1、添加seq/ack机制，确保数据发送到对端
> - 2、添加发送和接收缓冲区，主要是用户超时重传。
> - 3、添加超时重传机制。
>
> **详细说明：**送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。
>
> 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
> 发送：包的分片、包确认、包的重发
> 接收：包的调序、包的序号确认
>
> 目前有如下开源程序利用udp实现了可靠的数据传输。分别为***RUDP、RTP、UDT***:
>
> ##### 1、RTP（Real Time Protocol）
>
> *RTP为数据提供了具有实时特征的端对端传送服务*，如在组播或单播网络服务下的交互式视频音频或模拟数据。
>
> 应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。
>
> RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。
>
> ##### 2、RUDP（Reliable User Datagram Protocol）
>
> *RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等*，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。
>
> ##### 3、UDT（UDP-based Data Transfer Protocol）
>
> 基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。*UDT的主要目的是支持高速广域网上的海量数据传输*，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。
>
> 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。

---



### 五、操作系统

> [凉了！张三同学没答好「进程间通信」，被面试官挂了....](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)
>
> [面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ)
>
> [小林——进程和线程基础知识全家桶，30 张图一套带走](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485175&idx=1&sn=eda03758d4e810afd897ade44c19a508&scene=21#wechat_redirect)
>
> [[协程与线程、线程与进程的区别](https://www.cnblogs.com/bandaoyu/p/14624968.html)](https://www.cnblogs.com/bandaoyu/p/14624968.html)
>
> [初窥Linux 之 我最常用的20条命令](https://blog.csdn.net/ljianhui/article/details/11100625?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164775399016780261955887%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164775399016780261955887&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-11100625.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%B8%B8%E8%A7%81linux%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187)
>
> [进程上下文切换与线程上下文切换](https://blog.csdn.net/vjhghjghj/article/details/105353550)
>
> [进程、线程上下文切换](https://blog.csdn.net/m0_46598535/article/details/106320427)

#### [协程和线程的区别，线程与进程的区别](https://www.cnblogs.com/bandaoyu/p/14624968.html)

#### 内核态和用户态

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：**系统调用，异常和外围设备的中断**

[这次答应我，一举拿下 I/O 多路复用！](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

[面试官: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)

零拷贝

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

[看零拷贝之传统IO、mmap、sendfile、sendfile再优化](https://blog.csdn.net/Youth_lql/article/details/115524139)

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

**零拷贝**实现思想，就利用了**虚拟内存**这个点：多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，**就可以减少IO的数据拷贝次数啦**，示意图如下：

<img src="C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220303195205781.png" alt="image-20220303195205781" style="zoom:50%;" />

#### 进程间通信

即IPC机制——Inter-Process Communication

[凉了！张三同学没答好「进程间通信」，被面试官挂了....————————小林大佬，面试回答总结部分](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)

**什么是虚拟内存**

> 虚拟内存，是虚拟出来的内存，它的核心思想就是确保每个程序拥有自己的地址空间，地址空间被分成多个块，每一块都有连续的地址空间。同时物理空间也分成多个块，块大小和虚拟地址空间的块大小一致，操作系统会自动将虚拟地址空间映射到物理地址空间，程序只需关注虚拟内存，请求的也是虚拟内存，真正使用却是物理内存。

现代操作系统使用**虚拟内存**，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：

- 虚拟内存空间可以远远大于物理内存空间
- 多个虚拟内存可以指向同一个物理地址

#### [多线程访问共享资源——面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ)

#### 进程与线程上下文切换？

为什么线程切换比进程切换要快，进程切换会涉及到内核态吗，进程切换过程中内核态和用户态都做了哪些事？

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485175&idx=1&sn=eda03758d4e810afd897ade44c19a508&scene=21#wechat_redirect

> 进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
>
> 所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

> 线程的上下文切换相比进程，开销要小很多。
>
> - 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
> - **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，==虚拟内存==这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

>  **进程切换为何⽐线程慢**
>
> 涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换⽽线程不会。
> 因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏线程切换时不涉及虚拟地址空间的转换。
>
> 把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤
> Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。
> 由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了， cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。  

> 1、切换页表全局目录，使用新的虚拟地址空间
> 2、切换内核态堆栈
> 3、切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）
> 		ip(instruction pointer)：指向当前执行指令的下一条指令
> 		bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址
> 		sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址
> 		cr3:页目录基址寄存器，保存页目录表的物理地址
> 		…
> 4、刷新TLB
> 5、系统调度器的代码执行

#### **Linux常见命令：**

`/proc` 目录下都是虚拟文件，包含内核以及操作系统相关的动态信息

- linux下如何查看cpu信息——可以从文件cpuinfo读取，`cat /proc/cpuinfo`，可以查看几个cpu、单个cpu的物理核数、总逻辑核数等
- [linux系统命令之查看内存使用情况](https://blog.csdn.net/renfufei/article/details/105851728)
  - 包括物理内存RAM和交换内存
    - 使用`free -m`命令
    - 查看`/proc/meminfo`文件
    - 使用`vmstat -s`命令
    - `top` 命令一般用于查看进程的CPU和内存使用情况；当然也会报告内存总量，以及内存使用情况，所以可用来监控物理内存的使用情况
  - 查看物理内存的硬件信息，可以使用 `demidecode` 命令
- 查询操作系统中的进程——`ps或者top（进程的CPU和内存使用情况）` 
- 查看端口号命令——` lsof 和 netstat命令`
- 怎样更改文件的所属用户：`chown`
- linux命令`|`是无名管道，linux命令`mkfifo`是==命名管道

---

### Redis

> [面试官：Redis主节点宕机，如何处理？](https://mp.weixin.qq.com/s/bifB1blF_YeWsNNIybmB4w)
>
> [Redis 主从复制以及主从复制原理](https://mp.weixin.qq.com/s/NL-eSf5EXLtVZgDfC_q-LQ)
>
> [再也不怕，缓存雪崩、击穿、穿透！](https://mp.weixin.qq.com/s/_StOUX9Nu-Bo8UpX7ThZmg)
>
> [【面试官来袭】第一弹之Redis连击](https://mp.weixin.qq.com/s/CWSMW5UO0_xjnAmmaDcmjA)
>
> [一致性哈希是什么，使用场景，解决了什么问题？](https://mp.weixin.qq.com/s/Os2JOInK5PBLBCwUzh8Jfg)
>
> [Redis高可用方案：sentinel（哨兵模式）和集群](https://mp.weixin.qq.com/s/2LDkEMXDLAHroyr0uFb9sQ)
>
> [Redis夺命十二问。。](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)
>
> [redis的zset结构==跳表==](https://blog.csdn.net/qq_38545713/article/details/105439688)
>
> [2021年Redis面试题（持续更新）](https://blog.csdn.net/qq1515312832/article/details/113880849)
>
> [懵了~ 面试官Redis夺命连环20问！](https://mp.weixin.qq.com/s/u7738xkNuH2uPwdk8_Evjw)

#### [Redis 的五种基本数据类型](https://mp.weixin.qq.com/s/u7738xkNuH2uPwdk8_Evjw)

#### redis分布式锁

- setnx
- lua
- redisson
- RedLock

[面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)

[Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)

redis应用场景

部署redis集群

redis数据结构，跳表

[跳表：为什么 [Redis]一定要用跳表来实现有序集合？](https://blog.csdn.net/qq_38545713/article/details/105439688)

https流程说一下

redis主机宕机，从服务器升级为主服务器流程

[面试官：Redis主节点宕机，如何处理？](https://mp.weixin.qq.com/s/bifB1blF_YeWsNNIybmB4w)

[如何分配客户端的请求给服务器（节点）进行处理，一致性哈希是什么，使用场景，解决了什么问题？](https://mp.weixin.qq.com/s/Os2JOInK5PBLBCwUzh8Jfg)

[**那你再跟我说说Redis如何实现高可用吧？**](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)

[Redis高可用方案：sentinel（哨兵模式）和集群](https://mp.weixin.qq.com/s/2LDkEMXDLAHroyr0uFb9sQ)

- 主从复制
- 哨兵``
- 集群`cluster`

[Redis 主从复制以及主从复制原理](https://mp.weixin.qq.com/s/NL-eSf5EXLtVZgDfC_q-LQ)

---

### MySQL

> [你好，面试官 | 分析一下SQL执行慢的原因？如何排查，优化思路？（加餐篇）](https://mp.weixin.qq.com/s/XtjVp363Rev6EBHRzPtbhA)
>
> [mysql的锁](https://mp.weixin.qq.com/s/ptCOFqSuMBHm_4OmFPV2dg)
>
> [MySQL 经典 38 问！](https://mp.weixin.qq.com/s/FyN3bLo7LFz3aX31kI13yQ)
>
> [MySQL主从复制原理以及过程以及用到的三个重要线程](https://blog.csdn.net/jiayoudangdang/article/details/123167600)
>
> [MySQL相关问题整理](https://zyfcodes.blog.csdn.net/article/details/105361002)
>
> [如何解决MySQL中的死锁问题？](https://mp.weixin.qq.com/s/urZCVeEYkbrYr_cu--fgkg)
>
> [小林——告别 MVCC!](https://mp.weixin.qq.com/s/lbh7tJIANFsYRi_xfCpwJg)
>
> [高质量面经——面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

==mysql如何判断事务是否提交了==

> 比较事务版本号，mysql系统会有一个系统版本号，当每开启一个事务，mysql里有一个事务列表就会添加一个版本号，查看一个事务的版本号和列表中版本的关系来判断，该事务是否提交

聊聊索引在哪些场景下会失效？

> - \1. 查询条件包含or，可能导致索引失效
>
> - \2. 如何字段类型是字符串，where时一定用引号括起来，否则索引失效
>
> - \3. like通配符可能导致索引失效。
>
> - \4. 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
>
> - \5. 在索引列上使用mysql的内置函数，索引失效。
>
> - \6. 对索引列运算（如，+、-、*、/），索引失效。
>
> - \7. 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
>
> - \8. 索引字段上使用is null， is not null，可能导致索引失效。
>
> - \9. 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
>
> - \10. mysql估计使用全表扫描要比使用索引快,则不使用索引。

内链接、左联结、右联结的区别————csdn八股文收藏

> 左连接的定义：**左边有的，右边没有的为null**，是以左表为基础，根据ON后给出的两表的条件将两表连接起来。结果会将左表所有的查询信息列出，而右表只列出ON后条件与左表满足的部分。左连接全称为左外连接，是外连接的一种。
>
> 右连接与左连接相反
>
> **内连接：显示左边右边共有的**

表锁和行锁应用场景，什么条件下会触发，间隙锁

[mysql的锁🔒](https://mp.weixin.qq.com/s/ptCOFqSuMBHm_4OmFPV2dg)

#### [MySQL主从复制原理以及过程以及用到的三个重要线程](https://blog.csdn.net/jiayoudangdang/article/details/123167600)

#### 所谓==慢查询==

是指在Mysql中执行时间超过指定阈值的语句将被记录到慢查询文件中

 [你好，面试官 | 分析一下SQL执行慢的原因？如何排查，优化思路？（加餐篇）](https://mp.weixin.qq.com/s/XtjVp363Rev6EBHRzPtbhA))

#### [MySQL解决幻读——MVCC与临键锁](https://blog.csdn.net/QAQ123666/article/details/105084758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164792119816780265410477%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164792119816780265410477&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-105084758.142^v3^pc_search_result_cache,143^v4^control&utm_term=mvcc%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB&spm=1018.2226.3001.4187)

当前读：读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。

> 　　select...lock in share mode (共享读锁) 
>
> 　　select...for update（行级锁）
>
> 　　update , delete , insert

快照读：快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

> ​	不加锁的select操作

**在RR级别下，==快照读/普通读==是通过[MVVC(多版本控制)+undo log](https://blog.csdn.net/weixin_45325628/article/details/123292887?spm=1001.2014.3001.5502)来实现的，==当前读==是通过加record lock(记录锁/行锁)和gap lock(间隙锁)来实现的。**

当前读的幻读与解决方式：临键锁next-key locks = 行锁+间隙锁，在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。select * from table where id>3 锁住的就是id=3这条记录以及id>3这个区间范围，锁住索引记录之间的范围，避免范围间**插入**记录，以避免**产生幻影行**记录；

> 行锁（Record Lock）：锁直接加在索引记录上面。
>
> 间隙锁（Gap Lock）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。
>
> Next-Key Lock ：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身 。

**mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。**

**快照读的幻读是用MVCC解决的，当前读的幻读是用间隙锁解决的。**

[在RR级别下，mysql通过间隙锁可以防止幻读——插入](https://blog.csdn.net/m0_37556444/article/details/104479489)

#### innodb自动使用间隙锁的条件：

（1）必须在RR级别下（**解决幻读**）
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）



---

### 分布式加分项

CAS和ABA问题

**==对分布式的了解？==**

首先说一下cap和base理论，然后往分布式锁、负载均衡、redis集群高可用，去主动靠

目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。**分布式的CAP理论**告诉我们“任何一个分布式系统都无法同时满足**一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）**，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要**牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性**”，只要这个最终时间是在用户可以接受的范围内即可。

> **CAP**
>
> CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
>
> - 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
> - 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
> - 分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

> **BASE理论**
>
> BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
>
> - Basically Available（基本可用）
> - Soft state（软状态）
> - Eventually consistent（最终一致性）

- 分布式系统设计与开发
  - 分布式缓存
  - 分布式锁
    - [面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)
    - [Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)
- 分布式事务(解决方案)
- 负载均衡技术（在nginx服务器中配了3个tomcat服务器，每个tomcat服务器上都部署了整个系统，那么当请求数大的时候，可以分发到不同的tomcat。）
- 一致性哈希算法：很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。
  - 哈希环（通过虚拟节点提高均衡度）、redis哈希槽
- 系统容灾技术————mysql主从复制，redis持久化，哨兵监控、主复制写，从负责读
- 高可用系统————主从复制、哨兵监控（自动故障转移、恢复），集群（扩展单一服务器写能力和存储能力不足）

---

### 场景题

#### 1. [Bitmap有什么用大量数据的快速排序、查找、去重](https://www.cnblogs.com/cjsblog/p/11613708.html)

#### 2.10亿个数字，内存限制100M，进行排序

>  分治法：拆分小文件，先对每个小文件进行排序，然后使用小顶堆或大顶堆合并文件

#### 3.30亿数据下怎么去重，内存限制1G

> 方法一：
>
> 取数据（比如字符串，QQ号）的前n位做一个哈希，然后把哈希值一样的数据串放到一个文件里面。然后每次将一个文件load到内存中，然后对这个文件中的数据做个排序 or 哈希去重即可。借助hash算法思想，把一个大文件哈希分割到多个小文件中，而哈希冲突的数字一定会在同一个小文件中，从而保证了子问题的独立性，然后就可以单独对小文件通过快速排序来去重——这样就通过分而治之解决了几G数据进行内排序的问题。虽然哈希分割文件是O(n)的时间复杂度，但总的效率仍是依从快速排序的时间复杂度O(logn)。另外，分而治之有个好处就是借助子问题的独立性可以利用多核来做并行处理，甚至做分布式处理。这样的缺点是磁盘IO较多。
>
> 方法二：位图bitmap
>
> [腾讯三面：40亿个QQ号码如何去重?](https://blog.csdn.net/cainiao_python/article/details/121782198?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7.pc_relevant_default&utm_relevant_index=12)

#### 3.[如何保证mysql和redis的数据一致性？](https://www.cnblogs.com/shier-dong/p/15347134.html)

---

### 刷题

- 面试题16.10 生存人数（求多个区间的最大重合数量，及其对应的区间）——前缀和

- 数组中的第K个最大元素——快排

- 有序数组删除重复数字

- 给出0和1构成的二维数组，找出全部由0或者1构成的正方形边的最大值，——动态规划==[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)==

- [[380. O(1) 时间插入、删除和获取随机元素]](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/solution/chang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-j/)

  - 动态数组存储插入元素，哈希表存储元素在数组中的索引位置
  - 删除元素，首先判断是否在哈希表中，若存在，找到其索引`curInd`，在数组中交换索引`curInd`与`len-1`对应的值，将交换后的数组末尾元素删除，将其在哈希表中的索引也删除，同时更新原来末尾元素在哈希表中的索引为`curIdx`
  - 返回随机元素，`return nums(rand() % len);`

- [719找出第k小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

  - 双指针+二分法

  - 类似于————第k小的子数组和

    ```c++
    // 保证数组元素均为>= 0
    #include <bits/stdc++.h>
    using namespace std;
    int check(vector<int> &nums, int mid) { // 双指针法求小于等于mid的连续子数组个数
        int res = 0;
        int i = 0;
        int preSum = 0;
        for (int j = 0; j < nums.size(); j++) {
            preSum += nums[j];
            while (preSum > mid) { // 不必限制i <= j
                preSum -= nums[i];
                i++;
            }
            res += j - i + 1; // [i, j]可以组成(i)/(i,i+1)/(i,i+2)...(i,j-1)/(i,j)共i - j + 1个连续子数组
        }
    }
    int num_k_less_sum(vector<int> &nums, int k) { // 二分法求第k小的子数组和
        int l = 0, r = 1e9, mid, ans; // l为可能存在的最小数组和，r为最大
        while (l <= r) {
            mid = (l + r) >> 1;
            if (check(nums, mid) >= k) { // 子数组和小于等于mid的个数多于k个，说明r过大，需要缩小 
    			r = mid - 1;
                ans = mid; // 记录结果
            } 
            else {
                l = mid + 1;
            }
        }
        return ans;
    }
    int main() {
        int n, k;
        cin >> n >> k;
        vector<int> nums(n, 0);
        for (int i = 0; i < n; i++) {
            int num;
            cin >> num;
            nums[i] = num;
        }
        cout << num_k_less_sum(nums, k) << endl;
    }
    ```


- [694 不同岛屿（形状不同）的数量](https://blog.csdn.net/weixin_44171872/article/details/109014435)

  ```C++
  class solution {
  public:
      int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1}; // 上下左右
      int numDistinctIslands(vector<vector<int>>& grid) {
          set<vector<int>> st; // 该set集合中的元素vector是某个岛屿相对其左上角的坐标
          for (int i = 0; i < grid.size(); i++) {
              for (int j = 0; j < grid[0].size(); j++) {
                  if (grid[i][j] == 1) { // 发现岛屿的左上角节点(i,j)
                      queue<int> q; // BFS用
                      vector<int> cur; // 存储当前岛屿相对于grid[i][j]的坐标
                      q.push(i);
                      q.push(j);
                      grid[i][j] = 0; // 标记
                      while (!q.empty()){
                          int x = q.front();
                          q.pop();
                          int y = q.front();
                          q.pop();
                          // 将偏移节点坐标插入cur
                          cur.push_back(x - i);
                          cur.push_back(y - j);
                          for (int k = 0; k < 4; k++) { // bfs遍历
                          	int ni = x + dx[k], nj = y + dy[k];
                          	if (ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size() && grid[ni][nj] == 1) {
                              	grid[ni][nj] == 0; // 标记
                                  q.push(ni);
                                  q.push(nj);
                          	}
                      	}
                      }
                      st.insert(cur); // 将当前岛屿的形状坐标vector插入set中，形状相同的岛屿vector<int> cur也相同，set会自动去重
                  }
              }
          }
          return st.size(); // set集合的大小就是不同形状岛屿的数量
      }
  }
  ```




---

### 其他



**虚拟化**可以将一台主机划分为多个操作系统，每个操作系统还有独立的cpu资源，存储资源，内存资源。充分的利用的硬件资源。我知道的虚拟化产品：vmware 、MS

常见的几种**dos攻击**

答：tcp syn泛洪 ，ping泛洪，udp泛洪等等

DNS劫持是什么？

>  DNS是指将网页域名翻译为对应的IP的一种方法。DNS劫持指攻击者篡改结果，使用户对域名的解析IP变成了另一个IP。

> 3.20深信服C++开发工程师电话面：
>
> 用过哪些redis数据结构（使用场景），查看端口号命令、 iptables，docker，讲一讲项目中遇到的困难（具体），怎么解决的，登录解密的密钥，分组加密，长连接：超时时间、真正的长连接、学习go和python

[**倒排索引(Inverted Index)**](https://blog.csdn.net/hguisu/article/details/7962350?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164791892916782089327763%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164791892916782089327763&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-7962350.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。

[面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

> 1. 排序链表
>
> 2. 对称与非对称加密算法的区别
>
> 3. TCP如何保证可靠性
>
> 4. 聊聊五种IO模型
>
>    5. hystrix 工作原理
>
> 5. 延时场景处理
>
> 6. https请求过程
>
> 7. **聊聊事务隔离级别，以及可重复读实现原理**
>
> 8. 聊聊索引在哪些场景下会失效？
>
> 9. 什么是虚拟内存
>
> 10. 排行榜的实现，比如高考成绩排序
>
> 11. 分布式锁实现
>
> 12. 聊聊零拷贝
>
> 13. 聊聊synchronized
>
> 14. 分布式ID生成方案

MFC（Microsoft Foundation Classes，[微软]()基础类库）：是[微软]()公司实现的一个[c++]()类库，主要封装了大部分的windows API（Application Programming Interface）函数，并且包含一个应用程序框架，以减少应用程序开发人员工作量。

作者：三锤
链接：https://www.nowcoder.com/discuss/292489?channel=-1&source_id=profile_follow_post_nctrack
来源：牛客网

5、Float型数据与0是否相等：float型： 占4字节，7位有效数字；double型：占8字节，15～16位有效数字。浮点数的表示是不精确的，float和double都不能保证可以把所有实数都准确的保存在计算机中，所以不能直接比较两个数是否完全相等。一般都是在允许的某个范围内认为某个个浮点数相等，如有两个浮点数a、b，允许的误差范围为1e-6，则abs(a-b) <= 1e-6，即可认为a和b相等。

4.3计划

- [ ] 实验工件的设计

- [ ] 


重写与重载，隐藏的区别：

> 重写：发生在子类和父类之间，当子类继承父类中的方法时，子类中的方法与父类方法的名称，参数个数，参数类型完全一致时，称子类重写了父类的方法。
> 重载：一个类中的多个方法的名称相同，参数个数或者参数类型不同，则称为重载方法
> 覆盖：子类重新实现了父类的方法，而隐藏只是把父类中的方法藏了起来，通过父类的引用来调用这个方法的时候，这个被隐藏

