# 秋招

【2023秋招&提前批】互联网招聘信息最新汇总，不断更新ing！
https://docs.qq.com/sheet/DWElhT3VVSm5WTHNY

- 提前批代号`0`，秋招代号`1`
- 岗位名称后缀均为`工程师`
- 流程更新一栏末尾，`X`表示流程结束
- 自我评价：本人具有较强的快速学习能力，严谨的工作态度，强烈的责任心和良好的团队协作精神，善于沟通、乐于合作，热衷新技术，有强烈的技术好奇心和主动创新驱动力，善于总结分享，喜欢动手实践，注重自身能力的长期持续发展，对软件研发具有浓厚的兴趣；
- 简历中对应的获奖时间
- 通讯地址：重庆市沙坪坝区沙正街重庆大学A区
- 所在院系：机械与运载工程学院、船舶与海洋工程学院
- 项目题目：采用亚微米硅粉原料3D打印陶瓷汽车尾气过滤器
  - 大创项目介绍：本项目以亚微米硅粉为原料，采用3D打印技术成型，经无压氮化烧结制备氮化硅陶瓷汽车尾气过滤器。与现有产品相比，具有一次成型、简化后续胚体加工的特点，从而能够有效降低成本，产品具有耐高温、抗热冲击、抗氧化性能，并具备批量生产的可行性。
- 苏州西帝摩三维打印科技有限公司
  - 实习时间：2021/6/20-2021/9/30y
  - 作为结构研发实习生，协助公司研发部门对选区激光熔化SLM设备成形过程中的吹吸烟、充气等进行了流体仿真分析与优化，根据仿真结果对自研的SLM设备结构的更新迭代提出了重要指导，最终成果应用在XDM750大型PBLM设备上

#### 笔试记录：

1. 中望：
   1. 判断一个点point是否在一个多边形中，过该点作任意一条射线，与多边形的交点为偶数，则在外面，若为奇数，则在内部



| 序号 |                             公司                             |                             岗位                             | 地点 | 投递 |                           流程更新                           |
| ---- | :----------------------------------------------------------: | :----------------------------------------------------------: | ---- | :--: | :----------------------------------------------------------: |
| 1    | [多益网络](https://xz.duoyi.com/center/center.html#applynotify) |                           游戏研发                           | 成都 | 7/17 |                          测评挂`X`                           |
| 2    | [全志科技](https://campus.allwinnertech.com/campus-recruitment/allwinnertech/43436/#/candidateHome/applications) |                         应用软件设计                         | 珠海 | 7/17 |                                                              |
| 3    | [禾赛科技](https://kwh0jtf778.jobs.feishu.cn/referral/campus/position/application?token=MzsxNjU3Mjg5NzgxMDEyOzcxMTI2MTk2NDk0OTg0MzE0ODk7MA) |                           C++软件                            | 上海 | 7/18 |                                                              |
| 4    | [联发科技](http://mediatek-campus2023.zhaopin.com/job.html)  |                          嵌入式软件                          | 成都 | 7/18 |                         7/27笔试，？                         |
| 5    |      [北森](http://beisen.zhiye.com/Portal/Apply/Index)      |                             后端                             | 成都 | 7/18 |                                                              |
| 6    | [中科芯](https://xiaoyuan.zhaopin.com/job/CC000370676J00101482788?productId=7) |                             软件                             | 成都 | 7/20 |                                                              |
| 7    | [趋势科技](https://trendmicro.zhiye.com/Portal/Apply/Index)`0` |                         C++软件开发                          | 南京 | 7/20 |                         **8/5笔试**                          |
| 8    |      [OPPO](https://careers.oppo.com/campus/record)`0`       |                          驱动/系统                           | 成都 | 7/20 |                                                              |
| 9    |  [杭州大华](https://dahua.zhiye.com/Portal/Apply/Index)`0`   |                          C++大数据                           | 杭州 | 7/20 |                         7/25在线笔试                         |
| 10   | [北云科技](https://www.bynav.com/cn/careers/campus-recruitment/recruitment/925.html) |                          C/C++软件                           | 长沙 | 7/22 | 7/23在线笔试，8/2笔试：反转字符串、[445两个链表相加](https://leetcode.cn/problems/lMSNwu/)、3最长无重复字串、7整数翻转 |
| 11   | [集创北方](https://chipone.zhiye.com/Portal/Apply/Index)`0`  |                           软件开发                           | 深圳 | 7/22 |                                                              |
| 12   | [海尔](http://maker.haier.net/client/campus/mydeliverydetail/did/141524/jpid/0.html) |                           后端开发                           | 成都 | 7/22 |                          简历挂`X`                           |
| 13   | [元戎启行](https://app.mokahr.com/campus_apply/deeproute/6487#/candidateHome/resume) |                             软件                             | 深圳 | 7/22 |                     **8/4，14：00一面**                      |
| 14   | [星猿哲XYZ](https://app.mokahr.com/campus_apply/xyzrobotics/26847#/candidateHome/applications) |                           C++开发                            | 上海 | 7/23 |                           7/27笔试                           |
| 15   | [万集科技](https://fpq5u8xh3h.jobs.feishu.cn/201211/position/application) |                           C++开发                            | 北京 | 7/25 |                          简历挂`X`                           |
| 16   | [最右](https://app.mokahr.com/campus_apply/xiaochuankeji/3518#/candidateHome/applications)`0` |                           后台开发                           | 北京 | 7/27 |                                                              |
| 17   |     [联想](https://talent.lenovo.com.cn/resume/myapply)      |                          通信-5G/6G                          | 重庆 | 7/27 |                                                              |
| 18   | [SmartX](https://app.mokahr.com/campus_apply/smartx/4183#/candidateHome/applications)`0` |                             软件                             | 北京 | 7/27 |                          简历挂`X`                           |
| 19   | [中望](https://app.mokahr.com/campus_apply/zwcad/28356#/candidateHome/applications) |                           C++研发                            | 西安 | 7/28 |            7/28笔试，7/29约一面，**8/5下午一面**             |
| 20   | [TCL华星光电](https://sc.hotjob.cn/wt/TCL/web/index/applyPositionN300!listApplyPosition?brandCode=1&operational=db83422fa154075780d8209b41125d747fe69069ddc180fe77505b9e9fa8fdfa43b6e70a7fe6bb68052af8c01b77e9981ce8f61d1c3bd88c9f25618dfdd646f63fe20ff65c0d985708859c27d2c24cd0bf7a76546f789bde) |                        C/C++软件开发                         | 成都 | 7/28 |                       **8/2在线笔试**                        |
| 21   | [蔚来](https://nio.jobs.feishu.cn/campus/position/application?spread=SAYV33H)`0` |                           后端开发                           | 北京 | 7/29 |                                                              |
| 22   |   [ZOOM](https://www.nowcoder.com/users/570439010/deliver)   | [C++服务端开发](https://www.nowcoder.com/careers/zoom/102351?jobIds=75414) | 杭州 | 7/29 |                                                              |
| 23   | [华为数存](https://career.huawei.com/reccampportal/portal5/appjob-campus.html) |                           软件开发                           | 成都 | 7/29 |                                                              |
| 24   |      [京东发](http://campus.boe.com/Portal/Apply/Index)      |                           软件开发                           | 重庆 | 7/29 |                                                              |
| 25   | [中电55所](https://xiaoyuan.zhaopin.com/scrd/delivery/record) |                           软件研发                           | 南京 | 7/30 |                                                              |
| 26   | [科大讯飞](https://campus.iflytek.com/official-pc/delivery)  |                           C++开发                            | 西安 | 7/30 |                                                              |
| 27   | [招商证券](https://wecruit.hotjob.cn/SU629dbc0c0dcad452299bc0f7/pb/account.html#/myDeliver) |                           后台开发                           | 武汉 | 7/30 |                                                              |
| 28   | [歌尔](https://www.hotjob.cn/wt/GoerTek/web/index/CompGoerTekPageuserCenter?sendToDeliveryRecord=true&name=%E5%88%98%E6%8C%AF%E6%A3%AE%E9%87%8D%E5%BA%86%E5%A4%A7%E5%AD%A6%E6%AD%8C%E5%B0%94%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B2%97&redirect=true&applyId=&projectId=&lanType=1&brandCode=1&operational=0614eabd63fab7eacdfb80b90068e4703d03c8e61aeda8588f86c6f5386ea3d8dcdc049aeb94437c137c12119de10d41423b3c8a8f44445ca11d1e6488703bbda2ec84fe371b3f1041047149ce8363c5034edc6a528bf5013d4b5a0c8518c810a8a98ccf9826c90fb03fabd213693562e6ea7826fcbd52ef38c3cf2724595a2e55a578e90c58229a08d4d9c88ffa30d366d8d5f4e67b7414f37d246bacc94ab0272314cbb576cd2da67034da0f1c3b2cd8c2f872dc546e7f0f86085d5744db49f11b0f592e3cc43e12d40ae0fd9c81b2124755ff375cc77997ca6400716a9f34b03fabd213693562aa2b048c83f7ef79f13eb08cbc967983b0c69aa8ff4696ee6a7ef217c3536135bc07721643af3e1b5be88015265a6cd69535d0a031555ff81ef62fd60455675b286cd5de4758ce629d94dc5d30e544930cebce285506cc6d9b5635e5e03e2da90a78888a56c4a5ab1c98e0ff40ebbe2e1065baf0340b4f3dea64a6f5a157df3b10084dd359db0b86105b6c163ca981b8) |                          软件开发岗                          | 潍坊 | 7/30 |                                                              |
| 29   | [锐捷网络](https://app.mokahr.com/campus_apply/ruijie/56200?recommendCode=DSgE2uKR#/candidateHome/applications) |                          C/C++开发                           | 南京 | 7/30 |                                                              |
| 30   | [深信服](https://app.mokahr.com/campus_apply/sangfor/27944#/candidateHome/applications) |                        C/C++软件开发                         | 成都 | 7/30 |                                                              |
| 31   | [北斗星通](https://mp.weixin.qq.com/s/HbN0t9lIQ7lnmgw320hP9A) |                          HMI（C++）                          | 重庆 | 7/30 |                                                              |
| 32   | [嘉楠](https://canaan-creative.zhiye.com/Portal/Apply/Index) |                           AI编译器                           | 北京 | 7/30 |                                                              |
| 33   |   [虹软](http://career.arcsoft.com.cn/Portal/Apply/Index)    |                          C/C++开发                           | 杭州 | 7/30 |                                                              |
| 34   |  [传音控股](https://transsion.zhiye.com/Portal/Apply/Index)  |                        软件C/C++方向                         | 重庆 | 8/1  |                                                              |
| 35   |                            爱立信                            |                         软件开发C++                          | 上海 | 8/1  |                                                              |
| 36   | [荣耀](https://career.hihonor.com/SU60eea919bef57c1023f6fe78/pb/account.html#/myDeliver) |                         通用软件开发                         | 西安 | 8/1  |                                                              |
| 37   | [诺瓦星云](https://novastar.zhiye.com/Portal/Apply/Index)`0` |                           软件-C++                           | 西安 | 8/1  |                                                              |
| 38   | [滴滴](https://campus.didiglobal.com/campus_apply/didiglobal/6223#/candidateHome/applications) |                         后端研发C++                          | 北京 | 8/1  |                                                              |
| 39   | [哲库](https://app.mokahr.com/campus-recruitment/zeku/47716#/candidateHome/applications)`0` |                           软件开发                           | 成都 | 8/1  |                                                              |
| 40   | [英特尔](https://chinacampus.jobs.intel.cn/intel/user/delivery) |                  Network Software Engineer                   | 成都 | 8/2  |                                                              |
| 41   |       [美团](https://campus.meituan.com/apply-record)        |                           软件开发                           | 成都 | 8/2  |                                                              |
| 42   | [猿辅导](https://hr.yuanfudao.com/campus-recruitment/fenbi/47742/#/candidateHome/applications) |                          服务端开发                          | 北京 | 8/2  |                                                              |
| 42   |                           [微软]()                           |                   Software Engineer - STCA                   |      |      |                                                              |

==下午计划==

- [ ] 复习剑指offer
- [ ] 投递华为，准备华为机试，vs上写题
- [ ] 准备8/5中望面试d

# 我的八股文

## 一、`STL`与常见数据结构与算法

> [STL总结与常见面试题](https://mp.weixin.qq.com/s/JWAestcpQTlp2fb1Q45AQg)
>
> [vector扩容原理说明](https://blog.csdn.net/yangshiziping/article/details/52550291)
>
> 1. vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长固定指定大小的O(n)时间复杂度更好。
> 2. 为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。
>
> [c++vector容器的内存收缩和预留内存](https://blog.csdn.net/hacker_zrq/article/details/112849433)
>
> [c++11 之emplace_back 与 push_back的区别](https://ppipp.blog.csdn.net/article/details/84764104)
>
> [set和map区别](https://blog.csdn.net/lirui7610/article/details/79932949?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164931244516782184661859%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164931244516782184661859&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-79932949.142^v5^pc_search_result_cache,157^v4^control&utm_term=set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187)
>
> [红黑树与平衡二叉树的区别](https://blog.csdn.net/y506798278/article/details/104275033)
>
> [c++中map与unordered_map的区别](https://blog.csdn.net/zou_albert/article/details/106983268?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042694716780271939552%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165042694716780271939552&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106983268.142^v9^pc_search_result_control_group,157^v4^control&utm_term=c%2B%2Bunordered_map&spm=1018.2226.3001.4187)
>
> [哈希表的原理和使用](https://blog.csdn.net/weixin_38169413/article/details/81612307?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042689716782246411812%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165042689716782246411812&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-81612307.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8&spm=1018.2226.3001.4187)

### 1、[10大排序](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)

[C语言实现排序算法+动图](https://mp.weixin.qq.com/s/eKU_DCU0tLwyqfVvRrSLMA)

在最坏的情况下，待排序的序列已经为正序或者逆序，快速排序的时间复杂度为`O(n^2)`

| 排序算法     | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       |
| :----------- | :------------- | :------------- | :--------- | :------------------- |
| 冒泡排序     | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| 选择排序     | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| 插入排序     | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| **快速排序** | O(n*log2n)     | O(n2)          | O(log2n)   | **不稳定**           |
| 堆排序       | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定               |
| 归并排序     | O(n*log2n)     | O(n*log2n)     | O(n)       | **稳定**             |
| 希尔排序     | O(n*log2n)     | O(n2)          | O(1)       | 不稳定               |
| 计数排序     | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 |
| 桶排序       | O(n)           | O(n)           | O(m)       | 稳定                 |
| 基数排序     | O(k*n)         | O(n2)          |            | 稳定                 |

### 2、leetcode哪种题型比较深刻？

讲一下你在leetcode上刷题，对哪种题型或者哪道题印象比较深刻？

讲一下代码随想录的回溯5部曲、动态规划5步曲、二叉树（递归与迭代）、链表、字符串匹配、数组、图、滑动窗口、贪心算法

> 动态规划，Dynamic Programming，简称DP ，举例：左上角走到右下角最短路径
>
> 1. 确定dp数组（dp table）以及下标的含义
> 2. 确定递推公式
> 3. dp数组如何初始化(处理边界)
> 4. 确定遍历顺序
> 5. 举例推导dp数组  
> 6. 动态规划应该如何debug ：找问题的最好⽅式就是把dp数组打印出来，看看究竟是不是按照⾃⼰思路推导的！  

> 回溯算法
>
> 回溯法解决的问题都可以抽象为树形结构！
> 因为回溯法解决的都是在集合中递归查找⼦集， 集合的⼤⼩就构成了树的宽度，递归的深度，都构成的
> 树的深度。
> 递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）  
>
> ⼀般可以解决如下⼏种问题：
> 组合问题： N个数⾥⾯按⼀定规则找出k个数的集合
> 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
> ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
> 排列问题： N个数按⼀定规则全排列，有⼏种排列⽅式  
>
> 回溯三部曲
>
> - 回溯函数模板返回值以及参数  
>
> - 回溯函数终⽌条件  
>
> - 回溯搜索的遍历过程  
>
>   <img src="C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220405150012265.png" alt="image-20220405150012265" style="zoom: 67%;" />

### 3、讲一下比较熟悉的stl数据结构和算法

数据结构讲`vector`，算法就讲`sort排序算法`、查找算法（二分）

> 是动态空间，随着元素的加⼊，它的内部机制会⾃⾏扩充空间以容纳新元素。 vector 维护的是⼀个连续的线性空间，⽽且普通指针就可以满⾜要求作为 vector 的迭代器（RandomAccessIterator）。查找性能好
>
> vector 的数据结构中其实就是三个迭 代器构成的，⼀个指向⽬前使⽤空间头的 iterator，⼀个指向⽬前使⽤空间尾的iterator，⼀个指向⽬前可⽤空间尾的 iterator。当有新的元素插⼊时，如果⽬前
>
> 容量够⽤则直接插⼊，如果容量不够，则容量扩充⾄两倍，如果两倍容量不⾜， 就扩张⾄⾜够⼤的容量。
> 扩充的过程并不是直接在原有空间后⾯追加容量，⽽是重新申请⼀块连续空间，将原有的数据拷⻉到新空间中，再释放原有空间，完成⼀次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效。  

or

> 1. vector底层是一个**动态数组**，包含**三个迭代器**，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。
>
> 2. 扩容：当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间**（1.5倍或者2倍）**，然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。
>
>    1. vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。
>
>    2. 为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。
>
> 3. 当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
>
>    [c++vector容器的内存收缩和预留内存](https://blog.csdn.net/hacker_zrq/article/details/112849433)
>
> 4. 迭代器失效，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了
>
> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/0m4YX595FokDvfsaYelz5KmLlWcvwqWZIvsAOuYciboO87Q7CA60g0oJk6rh1xeyK7zicETuE9MzH76icd1rLP5DA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />



## 二、C++基础

### 面向对象三大特征

>  1、继承： 
>
>    被继承的是父类（基类），继承出来的类是子类（派生类），子类拥有父类的所有的特性。 
>
> -  继承方式有公有继承、私有继承，保护继承。默认是私有继承 
>
>   - 公有继承`public`中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。 
>
>   -  私有继承`private`中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。 
>
>   - 保护继承`protect`中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。 
>
> - c++语言允许单继承和多继承
>
> -  优点：继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性； 
>
> - 缺点：继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现；父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为；如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性，最终限制了复用性。 
>
> - 虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。 
>
>  2、多态： 
>
>  多态性是指对不同类的对象发出相同的消息将会有不同的实现 
>
>  C++有两种多态，称为**动多态（运行期多态）和静多态（编译器多态）**，静多态主要是通过模板、重写来实现，而动多态是通过虚函数来实现的。即在基类中存在虚函数（一般为纯虚函数）子类通过重载这些接口，使用基类的指针或者引用指向子类的对象，就可以调用子类对应的函数，动多态的函数调用机制是执行器期才能确定的，所以他是动态的。 
>
>  优点：大大提高了代码的可复用性；提高了了代码的可维护性，可扩充性； 
>
>  缺点：易读性比较不好，调试比较困难；模板只能定义在头文件中，当工程大了后，编译时间十分的变态； 
>
>  3、封装： 
>
>  隐藏类的属性和实现细节，仅仅对外提供接口， 
>
>  封装性实际上是由编译器去识别关键字public、private和protected来实现的，体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。私有成员是在封装体内被隐藏的部分，只有类体内说明的函数(类的成员函数)才可以访问私有成员，而在类体外的函数时不能访问的，公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。 
>
>  优点：隔离变化；便于使用；提高重用性；提高安全性 
>
>  缺点：如果封装太多，影响效率；使用者不能知道代码具体实现。

### 1. static

> 控制变量的存储方式和可见性。 
>
> (1)修饰局部变量
> 一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。
>
> (2)修饰全局变量
> 对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。
>
> 全局静态变量和局部静态变量的区别:
> 1.全局静态变量只能被当前源文件引用，不能被工程里其它源文件引用。除了这点特殊，其它与普通的全局变量一样。
> 2.局部静态变量，只执行一次初始化，只能被所在函数引用，函数执行完毕，变量仍存在，生存周期贯穿整个程序。
>
> (3)修饰函数
> 用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。
>
> (4)C++中的static
> ==如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的==

### 2. const的含义及使用场景和作用

```C++
const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。
 
(1)const修饰基本数据类型

 1.const修饰一般常量及数组
  
 基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 
  
 2.const修饰指针变量*及引用变量&  
 
如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

(2)const应用到函数中,  

 1.作为参数的const修饰符
 
 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。
 [注意]：参数const通常用于参数为指针或引用的情况; 
 
 2.作为函数返回值的const修饰符
 
 声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。
(3)const在类中的用法

不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行
类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。

(4)const修饰类对象，定义常量对象 
常量对象只能调用常量函数，别的成员函数都不能调用。
```

### 3. extern

```C++
在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

注意 extern 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
```

### 4. define宏定义与内联函数

> - 内联函数是指在==编译期间==用被调用的函数体本身来代替函数调用的指令
> - 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行==参数类型检查==（编译时），且具有返回值。
> - 内联函数==在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载==。
> - 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
> - 内联函数有类型检测、语法判断等功能，而宏没有
> - 内联函数也有==一定的局限性==。就是**函数中的执行代码不能太多了**，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样
> - 内联函数适用场景:
>   - 使用宏定义的地方都可以使用 inline 函数。
>   - 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。



### 5.虚函数： 虚函数的作用和实现原理，什么是虚函数,有什么作用?

```c++
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。	
    
动态多态满足的条件：
1. 有继承关系
2. 子类重写父类的虚函数
3. 父类的指针或者引用,执行子类对象
	
虚函数实现原理:包括虚函数表、虚函数指针等 

虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。
```

**虚函数表存放位置？linux全局数据区，windows常量段**[C++中虚函数、虚指针和虚表详解](https://blog.csdn.net/qq_20817327/article/details/108859161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164760442916780271554589%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164760442916780271554589&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-108859161.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8&spm=1018.2226.3001.4187)

每个声明了虚函数或者继承了有虚函数的类，都会有一个自己的==虚函数表vtbl==。同时该类的每个对象都会包含一个==虚指针vptr==去指向该`vtbl`。虚函数按照其声明顺序放于 `vtbl` 表中, `vtbl` 数组中的每一个元素对应一个函数指针。如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置。在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中.

如果 `normalize()`是一个 `virtual member function`，那么调用：**`ptr->normalize();`**

实际上会被编译器转化为：**`(*ptr->vptr[1])(ptr);`**

- `vptr` 是指向虚函数表的指针
- `1` 是表中该函数的索引，
- `ptr` 表示的是`this`指针

一个类只有一个虚函数表，每个表中可能含有三种类型的虚函数：

- 此类定义的函数实例。包括重写了父类中的虚函数
- 从父类中继承的且没有重写的虚函数
- 纯虚函数

### 6. **内联函数、构造函数、静态成员函数、模板函数可以是虚函数吗?**

对于虚函数有几点关键点：

- 虚函数是属于对象的
- 虚函数的和运行时期有关

由以上两点，可以回答原问题。

- `inline`：`inline` 需要在编译期就确定类的信息，但是虚函数具体是属于哪个类的，只有在动态运行时才能知道。
- `static`：静态函数是没有 `this` 指针，而虚函数是属于某个对象的`this`与`vptr`来调用的。
- `constructor`：虚函数等到运行时才知道是调用了哪个对象的虚函数。如果构造器也是虚函数，对象都无法构建。因此，构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被 `disable` 的。
- 模板函数 模板函数也不能是虚函数。因为，类会在`vtbl`中存放类中的所有的虚函数的函数指针，而一个模板函数如果设计为虚函数是无法获悉这个模板函数会被实例化为哪些具体的函数。

### 7. **为什么需要虚析构函数，什么时候不需要? 父类的析构函数为什么要定义为虚函数**

- 一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是**为了当用一个基类的指针删除一个派生类的对象时， 派生类的析构函数会被正确调用**。
- 当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。 所以，**只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**

### 8.纯虚函数，为什么需要纯虚函数？

```c++
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

virtual void funtion1()=0

原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)
纯虚函数不同的是父类绝对不能实现，且不能实例化，子类必须实现父类定义的虚函数接口，除非它也想成为抽象类，抽象类可以有部分方法实现，但至少要有一个纯虚函数的类才能叫抽象类。
Class B
{
public:
    virtual void fun1(){ cout << "fun1";} //虚函数，子类不用声明或实现
    virtual void fun2 = 0; //纯虚函数，子类必须声明并实现
};              
```

### 9.[虚析构函数（√）、纯虚析构函数（√）、虚构造函数（X）](https://www.cnblogs.com/chio/archive/2007/09/10/888260.html)

### 10. STL迭代器失效(拓跋阿秀八股)

> STL中迭代器失效的情况有哪些？
> **以vector为例：**
> 插入元素：
> 		1、尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
> 		2、中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size ==
> capacity时，所有迭代器均失效。
> 删除元素：
> 		1、尾后删除：只有尾迭代失效。
> 		2、中间删除：删除位置之后所有迭代失效。
> **deque 和 vector 的情况类似,**
> list双向链表每一个节点内存不连续, **删除节点仅当前迭代器失效**,erase返回下一个有效迭代器;
> map/set等关联容器底层是红黑树**删除节点不会影响其他**节点的迭代器, 使用递增方法获取下一个迭代器
> mmp.erase(iter++);
> unordered_(hash) 迭代器意义不大, **rehash之后, 迭代器应该也是全部失效**. 

### 11.右值引用与move语义

- 左值和右值的区别

  > 如`int a = 5 中的变量是左值，5是右值  `；
  >
  > 左值就是有名字的变量（对象），左值必须要在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中有实体；可以被赋值，可以在多条语句中使用，比
  >
  > 而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值
  >
  >  一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址

- [一文读懂C++右值引用和std::move—————详细好文](https://zhuanlan.zhihu.com/p/335994370)

  - 本文非常值得读，细致
  - 右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。
  - **由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在**  ；**通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去**  
  - 作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。
  - 在vector和string这个场景，加个`std::move`会调用到移动语义函数，避免了深拷贝，提升性能
  - **完美转发**，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换。std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。

- [c++ 之 std::move 原理实现与用法总结](https://ppipp.blog.csdn.net/article/details/84644069)

  - 在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是**将一个左值强制转化为右值引用，继而可以通过右值引用使用该值**，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);
  - C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
  - std::move是将对象的状态或者所有权从一个对象转移到另一个对象，**只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.**。原左lvalue值被moved from之后值被转移,所以变为空.

### 12.数组vector与链表list的区别

- 为什么[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)比链表查询速度更快？
  - 数组由于是紧凑连续存储,可以随机访问，通过**索引**快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
  - 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。
- 数组(**顺序存储**)和链表（**链式存储**）有以下不同：
  - **数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。**
  - *存储形式**：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个节点要保存相邻结点指针；**
  - **数据**查找**：数组的**线性查找速度快，查找操作直接使用偏移地址**。链表需要**按顺序检索结点**，效率低；**
  - **数据**插入或删除**：链表可以快速插入和删除结点，而数组则可能需要大量数据移动；**
  - 越界问题**：链表不存在越界问题，数组有越界问题。

### 13.常量指针和指针常量的区别：

> `常量指针const int *a`，指针**指向的内容是一个常量**，可以改变指向的地址，只要新地址里面也是常量就好。（小明原来住在六舍356，后来搬到357，不管是356还是357，里面住的都是小明）
>
> ```c++
> int a = 10, b = 20;
> const int *p = &a;
> p = &b; // 指针可以指向其他地址，但是内容不可改变
> cout << *p; // 10
> ```
>
> `指针常量int *const a  `，**指针自身的值是一个常量，指向的地址不能改变**，里面的内容可以修改，**在定义的同时必须初始化**（门牌号11，不管里面住谁，我指向的都是这条街11号）
>
> ```c++
> int a = 10, b = 20;
> int * const p = &a;
> *p = 30; // p指向的地址是一定的，但其内容可以修改
> p = &b; // 地址不能修改，error
> ```
>
> 
>
> 当然如果单纯为了区别两个中文，那么const=常量，*=指针，看谁在谁前面就叫对应的名字。

### 14.[c语言如何实现多态](https://blog.csdn.net/wenqiang1208/article/details/76244628)

### 15.介绍c语言指针

<img src="https://img-blog.csdnimg.cn/20200511093640946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIxNzU3Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" />

1. 指针的定义：指针是一个变量，用来存放地址的变量
2. 指针的类型：
   - 基本类型：int 、short、long、float 、double、char
     如 int *p；//表示定义一个指针，这个指针指向整形变量，这个指针将存放的是整形变量的地址。*
   - **数组指针：**指针指向一个数组
     `int (*a) [10]`表示指针a指向一个int型的长度为10的数组
   - **函数指针：**指针指向一个函数
     `void (*a) ();`/表示指针指向一个无参数无返回值的函数
3. 指针的引用：指针引用后得到的是该地址所对应的变量的值。
4. 二级指针：指向一级指针地址的指针
5. 指针的运算：
   - 指针`+`或者`-`一个数，表示指针加减这个数的类型所占内存的整数倍
     如` int *p=a;p=p+2;` , 在VC6.0里面，实际上p加了2 * 4=8
   - 指针减去一个指针，表示**两个指针之间所差的内存单元或者元素个数**，两个指针相加没有意义
   - 关系运算，如果定义了两个指针变量p和q，并且都已经初始化了，
     - 如果`p==q`，则表示p和q指向同一个地址
     - `p>q`,则表示p指向高地址而q指向低地址
     - 也经常拿`p和NULL`做比较，用来表示指针当前的状态，这在数据结构中应用非常广泛，比如说链表节点的查找、判断是否为空等等
6. 指针和数组的关系：
   指针和数组关系密切，数组可以通过指针去引用，数组可以存放指针，数组也可以由指针去访问，指针也能存放数组的地址

### 16.this指针是什么？调用函数的过程？

[C++ this指针详解（精辟） (biancheng.net)](http://c.biancheng.net/view/2226.html)

> this 是 [C++](http://c.biancheng.net/cplus/) 中的一个关键字，也是一个 const [指针](http://c.biancheng.net/c/80/)，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址，它指向当前对象，通过它`->`可以访问当前对象的所有成员。this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。
>
> - this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
>
> - **this****指针是什么时候创建的？****this****在成员函数的开始前构造，在成员函数的结束后清除**
>
> - this 到底是什么
>
>   this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
>
>   this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。
>
>   在《[C++函数编译原理和成员函数的实现](http://c.biancheng.net/view/vip_2220.html)》一节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。
>
> - 所谓当前对象，是指正在使用的对象。例如对于`stu.show();`，stu 就是当前对象，this 就指向 stu。
> - 类中`成员函数的参数`和`成员变量重名`时，只能通过 this 区分;
> - 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this
> - **this**指针存放在何处？this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。
> - 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用**，因为==如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的==
> - 

[C++中this指针的用法详解 - 优秀afa - 博客园 (cnblogs.com)————好文章](https://www.cnblogs.com/zhengfa-af/p/8082959.html)



### 17.智能指针`share_ptr`怎么实现的？是线程安全的吗？

1. 首先说一下为什么使用智能指针？

   > **智能指针是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的**  
   >
   > 智能指针其作⽤是管理⼀个指针，避免咱们程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。
   >
   > **因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。**   

2. `shared_ptr`的实现机制是**==在拷⻉构造时使⽤同⼀份引⽤计数==**  

   > （1）⼀个模板指针`T* _ptr`，指向实际的对象
   > （2）⼀个引⽤次数
   >           必须new出来的，不然会多个shared_ptr⾥⾯会有不同的引⽤次数⽽导致多次delete
   > （3）重载operator*和operator->
   >           使得能像指针⼀样使⽤shared_ptr
   > （4）重载copy constructor
   >           使其引⽤次数加⼀（拷⻉构造函数)
   > （5）重载operator=（赋值运算符）
   >           比如将b赋值给a，如果原来的shared_ptr a已经有对象，在赋值操作执行则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象引⽤次数加⼀
   > （6）重载析构函数
   >           使引⽤次数减⼀并判断引⽤是否为零; (是否调⽤delete)  

3. `shared_ptr`的线程安全问题

   >（1）同⼀个shared_ptr被多个线程“读”是安全的;
   >（2）同⼀个shared_ptr被多个线程“写”是不安全的;
   >证明：在多个线程中同时对⼀个shared_ptr循环执⾏两遍swap。 shared_ptr的swap函数的作⽤就是和另外⼀个shared_ptr交换引⽤对象和引⽤计数，是写操作。执⾏两遍swap之后, shared_ptr引⽤的对象的值应该不变）
   >（3）共享**引⽤计数的不同**的shared_ptr被多个线程”写“ 是安全的  

```c++
template<typename T>
class SharedPtr
{
private:
    T* _ptr; // (1)
    int* _pcount; // 指向引用计数的指针
public:
    // 初始化构造函数（有参数）
    SharedPtr(T* ptr == NULL): _ptr(ptr), _pcount(new int(1)) {}; // 初始化列表构造函数？
    // (3)
    T& opertor*() { // 返回智能指针this维护的指针_ptr指向的实际对象
        return *(this->_ptr);
    }
    T* opertor->() { // 返回该智能指针this中维护的指针_ptr
        return this->_ptr;
    }
    // (4)拷贝构造函数
    SharedPtr(const SharedPtr& s): _ptr(s._ptr), _pcount(s._pcount) {
        (*_pcount)++; // 当前对象的引用计数加一
    }
    // (5)重载=
    SharedPtr<T>& opertor=(const SharedPtr& s) {
        if (this != &s) {
            if (--(*(this->_pcount)) == 0) {
                delete this->_ptr;
                delete this->_pcount;
            }
            _ptr = s._ptr;
            _pcount = s._pcount;
            *(_pcount)++;
        }
        return *this;
    }
    // (6)
    ~SharedPtr() {
        --(*(this->_pcount) == 0) {
            delete _ptr;
            _ptr = NULL;
            delete _pcount;
            _pcount = NULL;
        }
    }
}
```

### 18.[内存泄露和内存溢出的区别和联系及产生原因](https://www.cnblogs.com/pan-louis/p/10768340.html)

一、什么是[内存溢出](https://so.csdn.net/so/search?q=内存溢出&spm=1001.2101.3001.7020)和内存泄露

1、内存泄漏（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。
2、内存溢出 （out of memory）：:指程序申请内存时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。也就是说给你个int类型的存储数据大小的空间，但是却存储一个long类型的数据，这样就会导致内存溢出。
二、内存溢出和[内存泄露](https://so.csdn.net/so/search?q=内存泄露&spm=1001.2101.3001.7020)的关系以及区别

1.关系：**内存泄露最终会导致内存溢出**，由于系统中的内存是有限的，如果过度占用资源而不及时释放，最后会导致内存不足，从而无法给所需要存储的数据提供足够的内存，从而导致内存溢出。导致内存溢出也可能是由于在给数据分配大小时没有根据实际要求分配，最后导致分配的内存无法满足数据的需求，从而导致内存溢出。

2.区别：内存泄露是由于GC无法及时或者无法识别可以回收的数据进行及时的回收，导致内存的浪费；内存溢出是由于数据所需要的内存无法得到满足，导致数据无法正常存储到内存中。内存泄露的多次表现就是会导致内存溢出。

> 内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越长，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。
>
> ==内存泄漏的分类==
>
> （1）堆内存泄漏 （Heap leak）
> 对内存指的是程序运⾏中根据需要分配通过malloc,realloc new等从堆中分配的⼀块内存，再是完成后必须通过调⽤对应的 free或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使⽤，就会产⽣ Heap Leak.
> （2）系统资源泄露（Resource Leak）
> 主要指程序使⽤系统分配的资源⽐如 Bitmap,handle ,SOCKET 等没有使⽤相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运⾏不稳定。
> （3）没有将基类的析构函数定义为虚函数
> 当基类指针指向⼦类对象时，如果基类的析构函数不是 virtual，那么⼦类的析构函数将不会被调⽤，⼦类的资源没有正确是释放，因此造成内存泄露。  

> ==避免内存泄露的几种方式==
>
> （1）使用智能指针，是为了解决动态分配内存导致内存泄露和多次释放同⼀内存所提出的  
>
> （2）计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如
> 果不为0则表示存在内存泄露
>
> （3）一定要将基类的析构函数声明为虚函数
> （4）对象数组的释放一定要用delete []
> （5）有new就有delete，有malloc就有free，保证它们一定成对出现  

> ==如何检测内存泄漏==
> （1）⾸先可以通过观察猜测是否可能发⽣内存泄漏， Linux 中使⽤` swap 命令`观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
> （2）还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 `netstat、 vmstat` 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
> （3）当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 ，`Linux下可以使用Valgrind工具，Windows下可以使用CRT库 `

### 19.什么情况下堆栈会溢出?

>  1.**函数调用层次太深**。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，`当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址`而造成栈溢出。 
>
>  2.**动态申请空间使用之后没有释放**。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。 
>
>  3.**数组访问越界**。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。 
>
>  4.**指针非法访问**。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误

### 20. C++ 中内存分配情况
> 问：在函数体内部创建的变量存放在什么位置？
>
> 答：一般的局部变量放在栈区，new/malloc创建的对象放在堆区，static修饰的变量放在全局静态区
>
> 
>
> **栈**：由编译器管理分配和回收，存放局部变量和函数参数。
> **堆**：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。
> **全局/静态存储区**：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。
> **常量存储区**：存储常量，⼀般不允许修改。
> **代码区**：存放程序的⼆进制代码  

### 21.sizeof

[C++ sizeof 详解](https://blog.csdn.net/MARSHCW/article/details/110306025?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042644816780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042644816780274146896&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-110306025.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%B8%B8%E8%A7%81sizeof&spm=1018.2226.3001.4187)

[sizeof与strlen的比较](https://blog.csdn.net/liitdar/article/details/81777539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042644816780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042644816780274146896&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-81777539.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%B8%B8%E8%A7%81sizeof&spm=1018.2226.3001.4187)

[常见面试题总结之C++中sizeof问题](https://blog.csdn.net/u013050857/article/details/70820935?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042644816780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042644816780274146896&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-70820935.142^v9^pc_search_result_control_group,157^v4^control&utm_term=C%2B%2B%E5%B8%B8%E8%A7%81sizeof&spm=1018.2226.3001.4187)

>- 定义：*sizeof*是一个操作符（*operator*）。其作用是返回一个对象或类型所占的内存字节数。其返回值类型为`*size_t*`。（*size_t*在头文件`*stddef.h*`中定义，它依赖于编译系统的值，一般定义为 *typedef unsigned int size_t;*）
>
>- ==数据类型的sizeof:==
>
>| int  | short | float | bool | double | char | 指针*                                                       |
>| ---- | ----- | ----- | ---- | ------ | :--- | ----------------------------------------------------------- |
>| 4    | 2     | 8     | 1    | 8      | 1    | 4（32位）指针变量的*sizeof*值与指针所指的对象没有任何关系。 |
>
>- 数组的*sizeof*值等于数组所占用的内存字节数。
>
> 注意：*1*）当字符数组表示字符串时，其*sizeof*值将*’/0’*计算进去。
>
> ​     	  *2*）当数组为形参时，其*sizeof*值相当于指针的*sizeof*值。
>
>- ==结构体struct的sizeof==
>
> - 涉及到字节对齐问题：算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了；
>
> - 字节对齐的细节和编译器的实现相关，但一般而言，满足三个准则：
>
>   - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
>
>   - 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；
>
>   - 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）
>
>   - ```c++
>     struct st{
>         char a;     //size=1 + 对界偏移为7
>         double b;   //size=8
>         int c;      //size=4
>         char d;     //size=1+对界偏移为3 
>     }; //最后输出为1+7+8+4+1+3=24
>     ```
>
>
>     class A{
>     public:
>          int a;//4
>          char b;//1+3
>      };
>      class B:public A{  // B继承A，sizeof(B)=1+3+4+1+3=12
>      public:
>          char c;
>      };
>     ```
>
> - 空结构体（不含数据成员）的*sizeof*值为*1*。试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。
>
>- ==联合体`Union`的sizeof==
>
> - 结构体在内存组织上是顺序式的，联合体则是重叠式，各成员共享一段内存；所以整个联合体的*sizeof*也就是每个成员*sizeof*的最大值。
>
> - union sizeof计算规则:sizeof(union)=最宽基本成员变量的字节数
>
> - ```c++
>   union uu{
>   	    int i;
>   	    char c;
>   	};//最后输出为4，因为最大字节为int的4字节
>   ```
>
>- ==string的sizeof==
>
> - sizeof(string)大小不一定，字符串所占的空间是从堆中动态分配的
> - 1、sizeof()返回的是string对象所占用的空间，而不是string所存储的字符串的大小。
>   2、string的实现在各库中可能有所不同，但是在同一库中相同的一点是，无论string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。   
>   3、sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现，VC6.0测试后sizeof(string)=16，说明还是跟编译器有关。
>
>- ==函数的sizeof==
>
> - sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。
>
> - 对函数求值的形式：sizeof(函数名(实参表))
>
>   注意：1）不可以对返回值类型为空的函数求值。 
>
>      		2）不可以对函数名求值。
>
>   ​           *3*）对有参数的函数，在用*sizeof*时，须写上实参表
>
>- ==sizeof与strlen的比较==
>
> - sizeof 是 C++ 编程语言的一个运算符，而 strlen 是一个函数（头文件为 string.h）；
> - sizeof 的操作对象（即操作数 operand）可以是数组、指针、类型、对象、函数等，而 strlen 的参数为字符型指针“const char * str”，当数组名作为 strlen 函数参数时，实际上在函数执行时该数组就退化成指针了；
> - sizeof 与 strlen 的返回值类型均为 size_t（即 unsigned int）；
> - sizeof 的值在编译的时候已经计算好了，而 strlen 是在运行时才计算的。由于是在编译时计算，因此 sizeof 不能用来计算动态分配的内存空间的大小，实际上，使用 sizeof 计算操作数（operand）的大小，其返回值跟操作数存储的内容无关；
> - strlen 函数实际完成的功能是从 str 字符串的第一个地址开始遍历，直到遇到结束符 NULL（'\0'）。需要注意，strlen 返回的字符串长度大小不包括 NULL（'\0'）；
>
>- 常见的一个面试题
>
> > 【HR】：定义一个空的类型，里面没有任何成员变量和成员函数，对该类型求sizeof得到结果是多少？
> >
> > 【acmer】：答案是1。
> >
> > 
> >
> > 【HR】：为什么不是0？
> >
> > 【acmer】：空类型的实例中不包括任何信息，本来求sizeof得到0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则则无法使用这些实例，至于占用多少内存，由编译器决定，Visual Studio 中每个空类型的实例占用1字节的空间。
> >
> > 
> >
> > 【HR】：如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到结果又是多少？
> >
> > 【acmer】：和前面一样，还是1.调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的类型只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数在实例内添加任何额外的信息。
> >
> > 
> >
> > 【HR】：那如果把析构函数标记为虚函数呢？
> >
> > 【acmer】：C++的编译器一旦发现一个类型中有虚拟函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，在32位的机器上，一个指针占4字节的空间，因此求sizeof得到4；在64位机器上，一个指针占8字节的空间，因此求sizeof得到8。

### 22.C++多线程

[C++11 多线程（std::thread）详解](https://blog.csdn.net/sjc_0910/article/details/118861539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165046387516782089343670%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165046387516782089343670&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-118861539.142^v9^pc_search_result_control_group,157^v4^control&utm_term=c%2B%2B%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4187)



---

## 三、项目

> [什么是彩虹表？——好文章](https://blog.csdn.net/nie19940803/article/details/76641498)
>
> [RSA加密算法原理](https://blog.csdn.net/a745233700/article/details/102341542?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5.pc_relevant_default&utm_relevant_index=8)————详细介绍RSA非对称加密算法
>
> [密码泄漏，不可小视——解决方案](https://mp.weixin.qq.com/s/nG2HjpXJQqRtZ3joRrUleQ)

### 1. 服务器端实现高并发——项目设计

1. TCP`socket,bind,listen...`+多线程

   - 优点：代码简单，结构清晰，把各种功能的业务代码放到线程函数里
   - 缺点：对服务器性能要求比较高，比如，虚拟机（1G内存，单核CPU，大概能够接受300个这种结构客户端的请求，如果再多，服务器创建线程时报错：内存不够）
   - 多线程只有在多核CPU上，才能体现出真正的并发优势，我们使用的阿里云轻量服务器是单核的，单核CPU使用多线程是一种伪并发，线程之间切换也需要时间
   - 综上：效率不高

2. select：文件描述符（对应一个客户端）的集合，单线程循环，对服务器性能要求相对较低，但是并发量有限（1024），处理效率低，一旦有数据可读的时候，需要循环遍历整个集合

3. epoll：对服务器性能要求相对较低，理论上并发量无限（资源毕竟有限，终将会消耗完），处理效率高，一旦有数据可读的时候，自己`epoll_event`事件结构体会直接跳出来，但是，缺点：同步（某个客户端的请求处理比较麻烦耗时，那么其他客户端在此期间的请求会监听不到）

4. epoll+多线程：解决3的缺点，epoll监听到某个客户端请求，启动一个线程，把他教给线程去处理，epoll本身继续执行监听任务，缺点：频繁启动线程，浪费时间和资源

5. epoll+线程池：解决4缺点，线程池是在服务器空闲的时候提前建立大量的线程，等待使用，处理完某个客户端请求之后，再把线程放回到线程池中

6. libevent（底层封装了epoll），集合中的事件不同于epoll中的epoll_event，叫做`buffer_event`，还封装了`TCP中的各种函数`，稳定；既然是封装了epoll，也是一种同步方式

7. ==本项目==：libevent+多线程，但是不同于4，因为`libevent`也是不允许多个线程同时操作事件集合`event_base`，涉及到同步问题，而且高并发下，多线程将资源会耗尽

   所以管理线程（监听），处理客户端请求时，新建工作线程（在这个里面再创建一个事件集合，）

   一个线程中只有一个事件，没有体现出libevent事件集合的优势

==**最好的实现方案设计：**==

- 聊天等功能时，使用`libevent+单线程`，因为聊天等功能都比较简单，不会很时，造成单线程的堵塞问题，且单线程下使用io多路复用可以处理高并发的聊天请求
- 传输文件功能时，再启用额外的线程，处理这种比较耗时的工作

### 2.说一下项目的难点

> 1. 考虑使用**多线程**解决高并发下处理用户请求、发送文件可能造成的堵塞，与单线程io多路复用文件发送依然会造成堵塞，影响用户在此期间的聊天功能
> 2. 实现登录功能时用户密码的加密问题
>    - 直接存储原密码，很容易泄露造成安全问题
>    - md5，使用某种哈希函数对原密码加密
>    - 一种**[彩虹表算法](https://blog.csdn.net/nie19940803/article/details/76641498)**专门用来破解哈希加密
>    - 防御彩虹表的一种方法是提高hash函数的计算难度，但是提高单次hash的计算难度有违hash的设计初衷。因此常见的方法是对特定的密码做大量反复的hash操作。例如将H定义为计算一千次MD5后的结果。这样的话，每个彩虹表项将对应1000个hash值和一个合法密码，这样的话彩虹表的k值不能取得太大，否则无法再可接受的时间内完成破解，而如果将k值取值减小，又大大的增加了彩虹表的空间。从而提高破解的成本。
>    - 综上，我才用==加盐`salt`+哈希函数加密==，防御彩虹表的破解
>      - 加盐是指通过在密码任意固定位置插入特定的字符串，让[散列](https://so.csdn.net/so/search?q=散列&spm=1001.2101.3001.7020)后的结果和使用原始密码的散列结果不相符
>      - 因此即使通过彩虹表找到了特定hash值对应的密码，也无法得到用户输入的密码，甚至根本得不到密码
>      - 即使破解者知道盐值和插入位置，也需要针对加盐的hash函数做对应的R函数修改，因此已有的彩虹表数据就完全无法使用，必须针对特定的H重新生成，这样就**提高了破解的难度**。

### 3. 任意hash函数应具备的特点

> 1.      压缩性：对于任意给定输入有唯一特定长度输出，例SHA1的hash值为20字节。
>2.      容易计算：即从原始数据计算hash值应该很容易。
> 3.      抗修改：对原始数据哪怕1bit的修改都会对hash值产生重大影响。
>4.      抗碰撞：这里分为强碰撞和弱碰撞，弱碰撞是给定一个数据很难找出相同hash值得另外一个数据。强碰撞是很难找出hash值相同的两个数据。
> 4.      单向性：即根据散列后hash值推断出原始输入值是很难的

### 4. libevent介绍

> 常见的I/O编程框架：
>
> 对比几个常见的I/O编程框架：libevent，libev，libuv，aio，boost.Asio。
>
> libevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。
> 设计模式 ：libevent为Reactor模式；
> 层次架构：livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务；
> 可移植性 ：libevent主要支持linux平台，freebsd平台，其他平台下通过select模型进行支持，效率不是太高；
> **事件分派处理 ：libevent基于注册的事件回调函数来实现事件分发**；
> 涉及范围 ：libevent只提供了简单的网络API的封装，线程池，内存池，递归锁等均需要自己实现；
> 线程调度 ：libevent的线程调度需要自己来注册不同的事件句柄；
> 发布方式 ：libevent为开源免费的，一般编译为静态库进行使用；
> 开发难度 ：基于libevent开发应用，相对容易，具体可以参考memcached这个开源的应用，里面使用了 libevent这个库。



## 四、计算机网络

> [计算机网络经典20问！](https://mp.weixin.qq.com/s/NCXN2iW_DpEHEiePDP7Yhg)
>
> [`http`面试问题集锦](https://www.cnblogs.com/rachelxiao/p/12423095.html )`http header`有什么内容

### 1、IO模型、多路复用select/poll/epoll

> [看一遍就理解：IO模型详解](https://mp.weixin.qq.com/s/bb7C6VNbq7REP9u8PsreSg)
>
> [这次答应我，一举拿下 I/O 多路复用！](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)
>
> [面试官: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)



### 2、OSI 的七层模型分别是？各自的功能是什么？每层对应的网络协议有哪些？

> [帅地玩编程网站版本](https://www.iamshuaidi.com/3612.html)
>
> 以下是小贺八股文版本
>
> ![image-20220709104746158](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709104746158.png)

<img src="https://image.iamshuaidi.com/picture/image-20210607144015234.png" alt="img" style="zoom: 67%;" />

### 3、TCP头部中包含哪些信息？

![图片](https://mmbiz.qpic.cn/mmbiz_png/g6WfVFoiaM5RDBxVUE6n2IgQTbicicPK9dzm9X0k1tb2GacJ6JqavsG6y7nCficnJxl850RE4WdDLpGRZufagaSp1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![image-20220709105918291](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709105918291.png)

### 4、http请求报文的请求头中一般有什么？

> 1）**Accept** 作用： 浏览器端可以接受的媒体类型 例：Accept ：text/html 
>
> 2）**Accept-Encoding**： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
>
> 3）**Accept-Language** 作用： 浏览器申明自己接收的语言。 例：Accept-Language: en-us
>
> 4）**Connection** 例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
>
> 5）**Host**（发送请求时，该报头域是必需的） **作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的**
>
> 6）Referer 作用：当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的
>
> 7）**User-Agent 作用：告诉HTTP服务器， 客户端使用的[操作系统](http://lib.csdn.net/base/operatingsystem)和浏览器的名称和版本**.



### 5、**http缓存机制**是怎样的，如何合理地缓存http？

> ==Http缓存主要分为两种：强缓存和协商缓存==
>
> 1）**强缓存基本原理是：所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据**。
>
> Expire 其指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的。但是它本身是一个HTTP1.0标准下的字段，所以如果请求中还有一个置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么 Expires 头就会被忽略。
>
> Cache-Control通用消息头用于在http 请求和响应中通过指定指令来实现缓存机制。其常用的几个取值有：
>
> private：客户端可以缓存
>
> public：客户端和代理服务器都可以缓存
>
> max-age=xxx：缓存的内容将在xxx 秒后失效
>
> s-max-age=xxx：同s-max-age，但仅适用于共享缓存(比如各个代理)，并且私有缓存中忽略。
>
> no-cache：需要使用协商缓存来验证缓存数据
>
> no-store：所有内容都不会缓存，强缓存和协商缓存都不会触发
>
> ==must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。==
>
> 2**）当强缓存过期未命中或者响应报文Cache-Control中有must-revalidate标识必须每次请求验证资源的状态时，便使用协商缓存的方式去处理缓存文件。**
>
> **协商缓存主要原理是从缓存数据库中取出缓存的标识，然后向浏览器发送请求验证请求的数据是否已经更新，如果已更新则返回新的数据，若未更新则使用缓存数据库中的缓存数据**



### 6、[TCP粘包问题](https://blog.csdn.net/weixin_41047704/article/details/85340311?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&utm_relevant_index=12)

>  “粘包问题”的概念用一句话说：就是，不同结构的多个包合成了一个大包，从而不知道怎么去把这个大包分割出原来的包。
>
>  解决方式：
>
>  1. **格式化数据：每条数据有固定的格式（开始符，结束符）**，这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
>  2. 发送长度：**发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度**，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。



### 7、**TCP如何保证可靠性**

- 首先，TCP的连接是==基于三次握手，而断开则是四次挥手。确保连接和断开的可靠性==。
- 其次，TCP的可靠性，还体现在==有状态==;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在==可控制==。它有==报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制==。



### 8、TCP流量控制——by滑动窗口

![image-20220709111410740](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709111410740.png)

### 9、拥塞控制算法

TCP四大拥塞控制算法总结？（极其重要）  ——————拓跋阿秀的八股文

![image-20220709120547125](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709120547125.png)

[《计算机网络》学习笔记 NO.029 TCP协议的拥塞控制](https://mp.weixin.qq.com/s/rqyc8zaW-7-pFTjO-N3p3A)

1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速恢复

### 10、如何区分流量控制和拥塞控制？

- 流量控制**属于通信双⽅协商**；拥塞控制涉及通信链路全局，拥塞控制是个庞大的问题，因为考虑到了整个网络。对于拥塞控制很难有最优解
- 大小————流量控制需要通信双⽅各维护⼀个发送窗、⼀个接收窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化**由试探性发送⼀定数据量数据探查⽹络状况后⽽⾃适应调整**。
- **实际最终发送窗⼝ = min{流控发送窗⼝，拥塞窗⼝}**  

### 11、解释一下超时重传和快速重传的区别——拓跋阿秀八股文

> ==超时重传==TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止 .
>
> 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做==快速重传==，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。  
>
> 超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：
>
> 1. 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.
> 2. cwnd重置为1
> 3. 进入慢启动过程
>
> 最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递  

> 所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：
>
> 1. cwnd大小缩小为当前的一半
>
> 2. ssthresh设置为缩小后的cwnd大小
>
> 3. 然后进入快速恢复算法Fast Recovery。  
>
>    #### 快速重传为什么是3次ack以后才开始？——拓跋阿秀
>
>    - 主要是为了区分包的丢失，是由什么原因引起的
>      - 1、包checksum出错，但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。  
>      - 2、网络拥塞
>      - 3、网路断/故障
>    - 如果在反向还可以接受到发送数据包的ack，可以认为网络没有断，否则也收不到ack，排除3
>    - 如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作  
>    - 如果接收到三个或三个以上的duplicated ACK，则大概率是丢包  ，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，说明先前的发送的包出错了，则一切OK，流速依然。  而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理

### 12、在浏览器中输入**url**地址后显示主页的过程?  

- 根据域名，进行**DNS域名解析**；
- 拿到解析的IP地址，**建立TCP连接**；  
- 向IP地址**，发送HTTP请求**；
- **服务器处理请求**；
- **返回响应结果**；
- 关闭TCP连接；
- **浏览器解析**HTML；浏览器布局**渲染**；  

### 13、DNS域名解析过程

（找到客户端发起的某个web服务器（域名：www.baidu.com）对应的IP地址)

浏览器的缓存——>系统hosts文件——>本地DNS服务器——>根域名服务器——>顶级域名服务器——>权限域名服务器。

> 1. 浏览器搜索**自己的DNS缓存**
>2. 若没有，则搜索**操作系统中的DNS缓存和hosts文件**
> 3. 若没有，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向**根域名服务器、顶级域名服务器、权限域名服务器**发起查询请求，最终返回IP地址给本地域名服务器
>4. 本地域名服务器将得到的IP地址返回给**操作系统**，同时自己也**将IP地址缓存起来**
> 5. 操作系统将 IP 地址返回给浏览器，**同时自己也将IP地址缓存起来**
>6. 浏览器得到域名对应的IP地址

两种查询方式：==微信收藏文章看图片==

递归查询：本地域名服务器作为DNS客户端的身份，递归的方式向其他更高级别的域名服务器进行递归查询，代替主机/客户端查询（本地域名服务器代替主机/客户端查询）；

迭代查询：当根域名服务器x本地服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该找哪个域名服务器y进行查询，然后本地服务器向y进行相同方式的迭代查询（告诉你位置，自己去找）

### 14、SYN攻击是什么？（SYN建立连接标志位）

SYN攻击就是Clien**t在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时**，这些伪造的SYN包将长时间**占用未连接队列**，**导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。**
==检测 SYN 攻击==非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击  。

`netstats -n -p TCP | grep SYN_RECV`

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，**耗费CPU和内存资源**。

==优化方式：==

1. 缩短SYN Timeout时间
2. **记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。**



### 15、**为什么https更加安全，ssl加密是怎样的？**

>  http是直接和tcp通信，https=http+ssl加密**；ssl加密：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”**，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，**HTTPS采用对称加密和非对称加密两者并用的混合加密机制**。

#### 	15-1、HTTPS的连接过程

> 1. 浏览器将支持的加密算法信息发给服务器
> 2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
> 3. ==客户端(SSL/TLS)解析证书验证证书合法性==，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
> 4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
> 5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
> 6. 服务器将客户端对称密钥加密后的密文发送给客户端
> 7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成



#### 15-2、HTTPS客户端验证CA机构颁发给服务器的数字证书过程

> 1. 什么是数字证书？
>
>    - 服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：**证书内容、证书签名算法和签名**，签名是为了验证身份。
>
>    - **数字签名的制作过程**：
>      1. CA使用证书签名算法对证书内容进行**hash运算**。
>      2. 对hash后的值**用CA的私钥加密**，得到数字签名。
> 2. 服务端把证书传输给浏览器**，浏览器从证书里取公钥**。证书可以证明该公钥对应本网站
> 3. **浏览器验证过程**：
>
>    1. 获取证书，得到证书内容、证书签名算法和数字签名。
>    2. 用CA机构的公钥**对数字签名解密**（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。
>    3. 用**证书里的签名算法**对**证书内容**进行hash运算。
>    4. 比较==解密后的数字签名==和==对证书内容做hash运算后得到的哈希值==，==**相等**==则表明证书可信。



### 16、常用对称与非对称加密算法有哪些

先复习一下相关概念：

> - 明文：指没有经过加密的信息/数据。
> - 密文：明文被加密算法加密之后，会变成密文，以确保数据安全。
> - 密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。
> - 加密：将明文变成密文的过程。
> - 解密：将密文还原为明文的过程。

对称加密算法:加密和解密使用**相同密钥**的加密算法。常见的对称加密算法有**AES、3DES、DES、RC5、RC6**等。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmRWNuUibfyQusbEibTQ1kuW4Bl7e4x0g9ra3KVjJCWFpiaKtcVH6ZxpKRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**非对称加密算法**：非对称加密算法需要两个密钥（**公开密钥和私有密钥**）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。主要的非对称加密算法有：**==[RSA](https://blog.csdn.net/a745233700/article/details/102341542)==、Elgamal、DSA、D-H、ECC**。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmQWfgJ9BeRH1f0CPUhhTBO7POHoLwwUibkjdLwepWkgFCP0kNXpSwm9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

### 17、[ARP与RARP协议](https://blog.csdn.net/dan15188387481/article/details/49823729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164896958216782092956115%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164896958216782092956115&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-49823729.142^v5^pc_search_result_cache,157^v4^control&utm_term=ARP%E4%B8%8ERARP%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187)

> 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
>
> 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
>
> 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。
>
> ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。
>
> ==ARP解析过程：==
>
> 1. 若A要知道B的mac地址，先判断自己的rap缓冲区中是否有B的ip和mac的映射，如果有，则直接得到B的mac地址，若没有，则发送rap广播请求包给该网络上的所有主机
> 2. 该网络上所有主机收到请求包后打开传给自己的上层----网络层，网络层判断是否是给自己的信息（判断数据包中的目的IP是否和自己的IP一样），若不是，则丢弃，若是（也就是B收到了），则将A的amc地址填充到自己的arp缓冲区中（方便下次使用），并将自己的mac地址填充到响应包中发送给A
> 3. A收到响应包后就知道了B的mac地址，然后将这个mac地址填充到自己的arp缓冲区中
> 4. 此外，若该网络中不存在B，即地址不可达，则A会收到一个地址不可达的ICMP包。ICMP（Internet控制报文协议）工作在网络层，用于传递差错信息，时间，回显等控制数据。
>
> **教材上把ARP协议划到网络层，是因为ARP协议属于TCP/IP协议簇。在TCP/IP模型中，它所有定义的协议是在网际层上的。**
>
> 再看按照OSI的标准，数据在传递时每层会加上自己的信息。当网络层的IP包进入链路层时，链路层通过ARP协议添加链路信息，而这不是网络层的功能。
>
> 所以有很多人说ARP是链路层的。
>
> 可以这样做，在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。
>
> 考试我们要按教材做，接网络层。



<img src="https://img-blog.csdnimg.cn/20191019105720115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcnRfX19fMzM5,size_10,color_FFFFFF,t_70" alt="img" style="zoom:33%;" />



### 18、`ping baidu.com`发生了什么？

> 1、首先进行DNS域名解析得到目标主机对应的ip地址
>
> - 主机查找本地系统Hosts文件的DNS缓存，如果存在www.baidu.com对应的IP,则获取IP；
> - 若本地系统没有对应IP，主机操作系统生成一个DNS查询报文，将[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)www.baidu.com放入DNS报文段中，进行DNS域名解析

> 2、`ping`过程：
>
> - `ping`命令的作用和原理
>   - **「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段**。
>   - ping 命令是基于` ICMP 协议`来工作的，`ICMP协议`是`“Internet Control Message Protocol”（因特网控制消息协议）`的缩写。它是`TCP/IP协议族`的一个子协议，**用于在`IP主机、路由器`之间传递控制消息**。`ping 命令`会发送一份`**ICMP回显请求报文**`给目标主机，**并等待目标主机返回`ICMP回显应答`**。因为`ICMP协议`会要求目标主机在收到消息之后，==必须返回`ICMP应答消息`给源主机==，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。
>   - [补充：什么是`ICMP`？](https://smile.blog.csdn.net/article/details/82782962)
>
> - ==举一个例子来描述**「ping」命令的工作过程**：==
>
> 1. 假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2
> 2. 此时，ping命令会在主机A上**构建一个 ICMP的请求数据包**（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。
> 3. IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，**构建成一个IP数据包**。
> 4. IP数据包构建完成后，还不够，还需要**加上MAC地址**，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并**交给数据链路层，组装成一个数据帧**，依据以太网的介质访问规则，将它们传送出出去。
> 5. 当主机B收到这个数据帧之后，会**首先检查它的目标MAC地址是不是本机**，**如果是就接收下来处理**，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会**构建一个ICMP应答数据包，回发给主机A**
> 6. **在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达**。**除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。**



### 19、[udp如何实现可靠传输](https://www.cnblogs.com/williamjie/p/11133180.html)

> UDP不属于连接协议，具有**资源消耗少，处理速度快**的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。
>
> 传输层无法保证数据的可靠传输，只**能通过应用层来实现了**。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
>
> 最简单的方式是==**在应用层模仿传输层TCP的可靠性传输**==。下面不考虑拥塞处理，可靠UDP的简单设计。
>
> - 1、添加序号seq、确认号ack机制，确保数据发送到对端
> - 2、添加发送和接收缓冲区，主要是用户超时重传。
> - 3、添加超时重传机制。
>
> **详细说明：**送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。
>
> 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
> 发送：包的分片、包确认、包的重发
> 接收：包的调序、包的序号确认
>
> 目前有如下开源程序利用udp实现了可靠的数据传输。分别为***RUDP、RTP、UDT***:
>
> ##### 1、RTP（Real Time Protocol）
>
> *RTP为数据提供了**具有实时特征的端对端传送服务***，如在组播或单播网络服务下的交互式视频音频或模拟数据。
>
> 应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。
>
> RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 **RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。**
>
> ##### 2、RUDP（Reliable User Datagram Protocol）
>
> *RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等*，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。
>
> ##### 3、UDT（UDP-based Data Transfer Protocol）
>
> 基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。***UDT的主要目的是支持高速广域网上的海量数据传输*，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。**
>
> 顾名思义，**UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。==它同时支持可靠的数据流传输和部分可靠的数据报传输==。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。**

---

## 五、操作系统

### 1、[进程间通信](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)————小林coding大佬

==面试可以回答最后的总结部分，如下：==

> 由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。
>
> Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。
>
> 1. ==**匿名管道**==顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
>
> 2. ==**命名管道**==突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。
>
> 3. ==**消息队列**==克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**
>
> 4. ==**共享内存**==可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**
>
> 5. 那么，就需要==**信号量**==来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。
>
> 6. =与信号量名字很相似的叫==**信号**==，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。
>
> 7. 前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要 ==Socket 通信了**==。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。
>
>    
>
> 以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？
>
> 同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：
>
> - 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
> - 同步的方式，可保证线程 A 应在线程 B 之前执行；

### 2、[多线程访问共享资源————面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ)————线程互斥

### 3、[小林——进程和线程基础知识全家桶，30 张图一套带走](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485175&idx=1&sn=eda03758d4e810afd897ade44c19a508&scene=21#wechat_redirect)

==仔细阅读，细节、全面、通俗的介绍了进程、线程、上下文切换、调度算法等非常重要的知识==

> <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9T1sqzavqAH3VIDxicaEtYMUwiagKpYBM5szUKj1F8KrkmuD99YokVuYg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />
>
> ==线程与进程的比较如下：==
>
> - ==进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位，==所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。
> - 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
> - 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
> - 线程能减少并发执行的时间和空间开销；
>
> ==对于，线程相比进程能减少开销，体现在：==
>
> - 线程的==创建==时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
> - 线程的==终止==时间比进程快，因为线程释放的资源相比进程少很多；
> - 同一个进程内的线程==切换==比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
> - 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的==数据交互效率==更高了；
>
> 所以，线程比进程不管是时间效率，还是空间效率都要高。
>
> [[协程与线程、线程与进程的区别](https://www.cnblogs.com/bandaoyu/p/14624968.html)]

### 4、内核态和用户态

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。**用户态拥有最低的特权级，内核态拥有较高的特权级**。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：**系统调用，异常和外围设备的中断**

### 5、零拷贝

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是**利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务**。这样就可以让系统资源的利用更加有效。

<img src="C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220712113048001.png" alt="image-20220712113048001" style="zoom:50%;" />

从 Linux 内核 `2.4` 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， `sendfile()` 系统调用的过程发生了点变化，如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。。这就是所谓的**零拷贝（\*Zero-copy\*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。**零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，**只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。**所以，总体来看，**零拷贝技术可以把文件传输的性能提高至少一倍以上**。

> [原来 8 张图，就可以搞懂「零拷贝」了](https://mp.weixin.qq.com/s/P0IP6c_qFhuebwdwD8HM7w)————小林coding，好文章
>
> <img src="C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220712102826366.png" alt="image-20220712102826366" style="zoom:50%;" />
>
>  [看零拷贝之传统IO、mmap、sendfile、sendfile再优化](https://imlql.cn/post/e959db2e.html)

**零拷贝**实现思想，就利用了**虚拟内存**这个点：多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，**就可以减少IO的数据拷贝次数啦**，示意图如下：

![image-20220709204308605](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220709204308605.png)

### 6、**什么是虚拟内存**

> 虚拟内存，是虚拟出来的内存，它的核心思想就是确保每个程序拥有自己的地址空间，地址空间被分成多个块，每一块都有连续的地址空间。同时物理空间也分成多个块，块大小和虚拟地址空间的块大小一致，**操作系统会自动将虚拟地址空间映射到物理地址空间，程序只需关注虚拟内存，请求的也是虚拟内存，真正使用却是物理内存。**
>
> 它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行**页面置换算法**，将该页置换到内存中  
>
> 但是虚拟内存使用的是硬盘的
> 空间，为什么我们要使用速度最慢的硬盘来做 为虚拟内存呢？因为电脑中所有运行的程序都需要经过内
> 存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M/512M内存消耗殆尽。而硬盘空
> 间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充
> 当内存使用。  	

现代操作系统使用**虚拟内存**，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：

- 虚拟内存空间可以**==大于==**物理内存空间
- 多个虚拟内存可以**指向同一个**物理地址————共享内存、零拷贝的`mmap()` 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作

### 7、进程与线程上下文切换？

> [进程和线程基础知识全家桶，30 张图一套带走](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485175&idx=1&sn=eda03758d4e810afd897ade44c19a508&scene=21#wechat_redirect)
>
> [进程上下文切换与线程上下文切换](https://blog.csdn.net/vjhghjghj/article/details/105353550)
>
> [进程、线程上下文切换](https://blog.csdn.net/m0_46598535/article/details/106320427)

为什么线程切换比进程切换要快，进程切换会涉及到内核态吗，进程切换过程中内核态和用户态都做了哪些事？

> 会，进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
>
> 所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

> ==线程的上下文切换相比进程，开销要小很多，为什么？==
>
> - 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
> - **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，==虚拟内存==这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

>  ==**进程切换为何⽐线程慢？**==
>
> 涉及到虚拟内存的问题，**进程切换涉及虚拟地址空间的切换⽽线程不会**。
> 因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏线程切换时不涉及虚拟地址空间的转换。
>
> 把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。
> **由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了， cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。**  

> 1、切换页表全局目录，使用新的虚拟地址空间
> 2、切换内核态堆栈
> 3、切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）
> 		ip(instruction pointer)：指向当前执行指令的下一条指令
> 		bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址
> 		sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址
> 		cr3:页目录基址寄存器，保存页目录表的物理地址
> 		…
> 4、刷新TLB
> 5、系统调度器的代码执行

### 8、**Linux常见命令：**

> [初窥Linux 之 我最常用的20条命令](https://blog.csdn.net/ljianhui/article/details/11100625?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164775399016780261955887%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164775399016780261955887&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-11100625.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%B8%B8%E8%A7%81linux%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187)
>
> - `/proc` 目录下都是虚拟文件，包含内核以及操作系统相关的动态信息
>
> - linux下如何查看cpu信息——可以从文件cpuinfo读取，`cat /proc/cpuinfo`，可以查看几个cpu、单个cpu的物理核数、总逻辑核数等
> - [linux系统命令之查看内存使用情况](https://blog.csdn.net/renfufei/article/details/105851728)
>   - 包括物理内存RAM和交换内存
>     - 使用`free -m`命令
>     - 查看`/proc/meminfo`文件
>     - 使用`vmstat -s`命令
>     - `top` 命令一般用于查看进程的CPU和内存使用情况；当然也会报告内存总量，以及内存使用情况，所以可用来监控物理内存的使用情况
>   - 查看物理内存的硬件信息，可以使用 `demidecode` 命令
> - 查询操作系统中的进程——`ps或者top（进程的CPU和内存使用情况）` 
> - 查看端口号命令——` lsof 和 netstat命令`
> - 怎样更改文件的所属用户：`chown`
> - linux命令`|`是无名管道，linux命令`mkfifo`是==命名管道

---



## 六、Redis

> ### 特别适合面试——[懵了~ 面试官Redis夺命连环20问！](https://mp.weixin.qq.com/s/u7738xkNuH2uPwdk8_Evjw)
>
> <img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpz5ftMEn1xpdGVqjkEhEQD5gEsk1zGeh3fk0e95tsLKRBib7ujGJZpBmtgBOAwdgViaZQzjNpuJYYsQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:150%;" />
>
> 
>
> [小林大佬。Redis面试总结，告别Redis！](https://mp.weixin.qq.com/s/3Bm1h_oEi4X4b_RIldUekw)
>
> ![image-20220715175934298](C:\Users\Admin003\AppData\Roaming\Typora\typora-user-images\image-20220715175934298.png)
>
> [【面试官来袭】第一弹之Redis连击](https://mp.weixin.qq.com/s/CWSMW5UO0_xjnAmmaDcmjA)
>
> [Redis夺命十二问。。](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)
>
> [2021年Redis面试题（持续更新）](https://blog.csdn.net/qq1515312832/article/details/113880849)

### 1、Redis 常见数据类型和应用场景

> [**小林大佬——Redis 常见数据类型和==应用场景——非常详细，必看内容==**](https://www.xiaolincoding.com/redis/data_struct/command.html)
>
> [小林大佬。Redis面试总结，告别Redis！](https://mp.weixin.qq.com/s/3Bm1h_oEi4X4b_RIldUekw)
>
> [Redis 的五种基本数据类型](https://mp.weixin.qq.com/s/u7738xkNuH2uPwdk8_Evjw)
>
> 可以自己本机安装 Redis 或者通过 Redis 官网提供的[在线 Redis 环境 (opens new window)](https://try.redis.io/)来敲命令

#### 1、String

> ==介绍==String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M；
>
> <img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpz5ftMEn1xpdGVqjkEhEQD5cJg67LmHKrS1brhxJr6c2UjpgyWHIQWwKPhQNEqmtev8TYsjp3fibpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />
>
> ==内部实现==
>
> String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。
>
> SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：
>
> - **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 `SDS` 使用 `len` 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 `buf[]` 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
> - **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 `len` 属性记录了字符串长度，所以复杂度为 `O(1)`。
> - **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。
>
> 字符串对象的内部编码（encoding）有 3 种 ：**int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）**。
>
> 
>
> ==应用场景==——缓存对象、常规计数（比如计算访问次数、点赞、转发、库存数量等）、分布式锁（SET 命令有个 NX 参数可以实现「key不存在才插入」）、分布式系统下共享`Session`信息

#### 2、List

> ==介绍==List 列表是简单的字符串列表，**按照插入顺序排序**，可以从头部或尾部向 List 列表添加元素。列表的最大长度为 `2^32 - 1`，也即每个列表支持超过 `40 亿`个元素
>
> <img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpz5ftMEn1xpdGVqjkEhEQD5cJg67LmHKrS1brhxJr6c2UjpgyWHIQWwKPhQNEqmtev8TYsjp3fibpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />
>
> ==内部实现==
>
> List 类型的底层数据结构是由**双向链表或压缩列表**实现的：
>
> - 如果列表的元素个数小于 `512` 个（默认值，可由 `list-max-ziplist-entries` 配置），列表每个元素的值都小于 `64` 字节（默认值，可由 `list-max-ziplist-value` 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
> - 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；
>
> 但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。
>
> ==常用命令==
>
> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list.png" alt="img" style="zoom:33%;" />
>
> ```shell
> # 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面
> LPUSH key value [value ...] 
> # 将一个或多个值value插入到key列表的表尾(最右边)
> RPUSH key value [value ...]
> # 移除并返回key列表的头元素
> LPOP key     
> # 移除并返回key列表的尾元素
> RPOP key 
> 
> # 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始
> LRANGE key start stop
> 
> # 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞
> BLPOP key [key ...] timeout
> # 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞
> BRPOP key [key ...] timeout
> ```
>
> ==应用场景==
>
> - `lpush+lpop=Stack`（栈）
> - `lpush+rpop=Queue`（队列）
> - `lpush+ltrim=Capped Collection`（有限集合）
> - `lpush+brpop=Message Queue`**（消息队列）**，`BRPOP`命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。**和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销**。
>   - 基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。
>     - 消息保序：使用 LPUSH + RPOP；
>     - 阻塞读取：使用 BRPOP；
>     - 重复消息处理：生产者自行实现全局唯一 ID；
>     - 消息的可靠性：使用 BRPOPLPUSH
>   - List 作为消息队列有什么缺陷？
>     - **List 不支持多个消费者消费同一条消息**，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。
>     - 要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 **List 类型并不支持消费组的实现**。
>     - 这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取

#### 3、Hash

> ==介绍==Hash 是一个键值对`（key - value）`集合，其中 `value `的形式如： `value=[{field1，value1}，...{fieldN，valueN}]`。Hash 特别适合用于存储对象。
>
> ==内部实现==
>
> Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：
>
> - 如果哈希类型元素个数小于 `512` 个（默认值，可由 `hash-max-ziplist-entries` 配置），所有值小于 `64` 字节（默认值，可由 `hash-max-ziplist-value` 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
> - 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的 底层数据结构。——————哈希冲突时，动态搬迁
>
> **在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**
>
> ==常用命令==
>
> ```shell
> # 存储一个哈希表key的键值
> HSET key field value   
> # 获取哈希表key对应的field键值
> HGET key field
> 
> # 在一个哈希表key中存储多个键值对
> HMSET key field value [field value...] 
> # 批量获取哈希表key中多个field键值
> HMGET key field [field ...]       
> # 删除哈希表key中的field键值
> HDEL key field [field ...]    
> 
> # 返回哈希表key中field的数量
> HLEN key       
> # 返回哈希表key中所有的键值
> HGETALL key 
> 
> # 为哈希表key中field键的值加上增量n
> HINCRBY key field n                         
> ```
>
> ==应用场景==
>
> ###### 缓存对象
>
> **Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。**
>
> 我们以用户信息为例，它在关系型数据库中的结构是这样的：
>
> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.png)
>
> 我们可以使用如下命令，将用户对象的信息存储到 Hash 类型：
>
> ```shell
> # 存储一个哈希表uid:1的键值
> > HSET uid:1 name Tom age 15
> 2
> # 存储一个哈希表uid:2的键值
> > HSET uid:2 name Jerry age 13
> 2
> # 获取哈希表用户id为1中所有的键值
> > HGETALL uid:1
> 1) "name"
> 2) "Tom"
> 3) "age"
> 4) "15"
> ```
>
> Redis Hash 存储其结构如下图：
>
> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="img" style="zoom:33%;" />
>
> 在介绍 String 类型的应用场景时有所介绍，String + Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢？
>
> 一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。
>
> ###### 购物车
>
> 以**用户 id 为 key，商品 id 为 field，商品数量为 value**，恰好构成了购物车的3个要素，如下图所示。
>
> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%B4%AD%E7%89%A9%E8%BD%A6.png" alt="img" style="zoom: 33%;" />
>
> 涉及的命令如下：
>
> - 添加商品：`HSET lzs521 袜子 2`  // lzs521即为用户id，袜子即为商品id，2为袜子的数量
> - 添加数量：`HINCRBY lzs521 袜子 4`  // 袜子的数量增加4
> - 批量添加商品：`HMSET LZS521 鞋 1 短袖3`  // 用户的购物车又添加了鞋 1，短袖3件
> - 商品总数：`HLEN LZS521 ` // 3种
> - 删除商品：`HDEL cart:{用户id} {商品id}`
> - 获取购物车所有商品：`HGETALL cart:{用户id}`  // 返回所有商品各有多少
>
> 当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。

#### 4、集合set

> ==介绍==Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。一个集合最多可以存储 `2^32-1` 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 **Set 类型除了支持集合内的增删改查，同时还****支持多个集合取交集、并集、差集**。
>
> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/set.png" alt="img" style="zoom:33%;" />
>
> Set 类型和 List 类型的区别如下：
>
> - List 可以存储重复元素，Set 只能存储非重复元素；
> - List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。
>
> ==内部实现==
>
> Set 类型的底层数据结构是由**哈希表或整数集合**实现的：
>
> - 如果集合中的元素都是整数且元素个数小于 `512` （默认值，`set-maxintset-entries`配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
> - 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构
>
> ==常用命令==
>
> Set常用操作：
>
> ```shell
> # 往集合key中存入元素，元素存在则忽略，若key不存在则新建
> SADD key member [member ...]
> # 从集合key中删除元素
> SREM key member [member ...] 
> # 获取集合key中所有元素
> SMEMBERS key
> # 获取集合key中的元素个数
> SCARD key
> 
> # 判断member元素是否存在于集合key中
> SISMEMBER key member
> 
> # 从集合key中随机选出count个元素，元素不从key中删除
> SRANDMEMBER key [count]
> # 从集合key中随机选出count个元素，元素从key中删除
> SPOP key [count]
> ```
>
> Set运算操作：
>
> ```shell
> # 交集运算
> SINTER key [key ...]
> # 将交集结果存入新集合destination中
> SINTERSTORE destination key [key ...]
> 
> # 并集运算
> SUNION key [key ...]
> # 将并集结果存入新集合destination中
> SUNIONSTORE destination key [key ...]
> 
> # 差集运算
> SDIFF key [key ...]
> # 将差集结果存入新集合destination中
> SDIFFSTORE destination key [key ...]
> ```
>
> ==[应用场景](https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4)==——点赞/共同关注/抽奖
>
> 集合的主要几个特性，无序、不可重复、支持并交差等操作。
>
> **因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。**
>
> 但是这里有一个潜在的风险。**Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞**。
>
> 在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。

#### 5、有序集合Zset

> ==介绍==
>
> Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。**有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。**
>
> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/zset.png" alt="img" style="zoom: 50%;" />
>
> ==内部实现==
>
> Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：
>
> - 如果有序集合的元素个数小于 `128` 个，并且每个元素的值小于 `64` 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
> - 如果有序集合的元素不满足上面的条件，Redis 会使用==**跳表**==作为 Zset 类型的底层数据结构；
>
> **在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**
>
> ==常用命令==
>
> Zset 常用操作：
>
> ```shell
> # 往有序集合key中加入带分值元素
> ZADD key score member [[score member]...]   
> # 往有序集合key中删除元素
> ZREM key member [member...]                 
> # 返回有序集合key中元素member的分值
> ZSCORE key member
> # 返回有序集合key中元素个数
> ZCARD key 
> 
> # 为有序集合key中元素member的分值加上increment
> ZINCRBY key increment member 
> 
> # 正序获取有序集合key从start下标到stop下标的元素
> ZRANGE key start stop [WITHSCORES]
> # 倒序获取有序集合key从start下标到stop下标的元素
> ZREVRANGE key start stop [WITHSCORES]
> 
> # 返回有序集合中指定分数区间内的成员，分数由低到高排序。
> ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
> 
> # 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。
> ZRANGEBYLEX key min max [LIMIT offset count]
> # 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同
> ZREVRANGEBYLEX key max min [LIMIT offset count]
> ```
>
> Zset 运算操作（**相比于 Set 类型，ZSet 类型没有支持差集运算**）：
>
> ```shell
> # 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积
> ZUNIONSTORE destkey numberkeys key [key...] 
> # 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积
> ZINTERSTORE destkey numberkeys key [key...]
> ```
>
> ==[应用场景](https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5)==
>
> Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。
>
> 在面对需要展示最新列表、**排行榜等**场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。
>
> 有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。

#### 6、新增数据类型

> `Redis` 后续版本又支持四种数据类型，它们的应用场景如下：
>
> - `BitMap`（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
> - `HyperLogLog`（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
> - `GEO`（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
> - `Stream`（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

### 2、跳表`skip list`

> [跳表：为什么 [Redis]一定要用跳表来实现有序集合？](https://blog.csdn.net/qq_38545713/article/details/105439688)
>
> ==跳表==
>
> - 相当于基于单链表加多级索引的结构实现了二分查找，查找的时间复杂度为、
> - 高效的动态插入和删除，查找某个数据应该插入的位置；查找要删除节点的时候，一定要获取其前驱节点（若使用双向链表就不用），时间复杂度也都是 o(logn)；
> - 索引会动态更新
>   - 当我们不停的往跳表中插入数据时，如果我们不更新索引，就可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表会退化成单链表，查找、插入、删除操作性能下降。 
>   - 往跳表中插入数据的时候，可以选择同时将这个数据插入到第几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中
>   - 随机函数可以保证跳表的索引大小和数据大小的平衡性，不至于性能过度退化。
>   - <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTk4OTQ3OS04MjAyMzczY2QyYzhhN2M5LmpwZw?x-oss-process=image/format,png" alt="img" style="zoom:67%;" />
>
> 回答题目问题，Redis 中的有序集合支持的核心操作主要有下面这几个： 
>
> - 插入一个数据
> - 删除一个数据
> - 查找一个数据
> - 按照区间查找数据（比如查找在[100,356]之间的数据）
> - 迭代输出有序序列 
> - 跳表与红黑树
>   - ==其中，插入、查找、删除以及迭代输出有序序列这几个操作，红黑树也能完成，时间复杂度和跳表是一样的，但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高==，对于按照区间查找数据这个操作，跳表可以做到 ○(㏒n) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。 
>   - ==跳表代码更容易实现，可读性好不易出错。跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗==。 
>   - 不过跳表也不能完全替代红黑树。因为红黑树出现的更早一些。很多编程语言中的 Map 类型都是用红黑树来实现的。写业务的时候直接用就行，但是==跳表没有现成的实现，开发中想用跳表，得自己实现==。[ ](https://www.cnblogs.com/ysocean/p/9080942.html)

### 3、[再也不怕，缓存雪崩、击穿、穿透！](https://mp.weixin.qq.com/s/_StOUX9Nu-Bo8UpX7ThZmg)

> <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf6AeSYo05YHWBXHrpibN5Psyx75Dqiaqw2tsX2g3AQaSp43E9R0oVHQ1Jy1xB8E8YOSeJgjUmgPX7Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

### 4、[Redis==主从复制==以及主从复制原理](https://mp.weixin.qq.com/s/NL-eSf5EXLtVZgDfC_q-LQ)

### 5、[面试官：Redis主节点宕机，如何处理？](https://mp.weixin.qq.com/s/bifB1blF_YeWsNNIybmB4w)——哨兵的作用

> 如果是主节点宕机了，那就有点麻烦了，毕竟写操作是在主节点上，无法替代，这时候就需要从所有的`从库`节点中挑选一台做为主节点。
>
> **哨兵机制`Sentienl`分为三个阶段：**
>
> 1、**监控**。哨兵进程会周期给所有的主库、从库发送 PING 命令，检测机器是否处于服务状态。如果没有在设置时间内收到回复，则判定为下线。
>
> 2、**选主**。主要是看各个节点的打分情况，打分规则分为 `从库优先级`、`从库复制进度`、`从库ID号`。只要有一轮，某个从库得分最高，则选举它为主库。
>
> - 从库优先级，主要是考虑到不同的机器可能配置不一样，配置高的机器，优先级高一些，通过`slave-priority` 来配置
>
> - 从库复制进度，主要是看`slave_repl_offset` 的值大小，值越大表示已经同步的数据越多，得分越高。
> - 从库ID号，每个Redis 实例启动时，都会生成一个 ID，在优先级和复制进度相同的条件下，ID号最小的从库分数最高，会被选为新主库。
>
> 3、**通知**。把选举后的新主库发送给所有节点，让所有的从库执行 `replicaof` 命令，和新 master建立主从关系、数据同步复制。另外，也会把最新的主库信息同步给客户端。这样后续的写请求会打到新的 主节点上。
>
> 
>
> **为了防止网络误判主节点下线，使用哨兵集群机制**，至少有 quorum 个sentinel主观的认为这个master有故障，才会对这个master下线或故障转移，即主节点客观下线；接下来，需要选取一个带头的哨兵，执行接下来的选主，另外哨兵集群的搭建需要借助`Redis`的发布/订阅`pub/sub`机制
>
> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPDgZP00p7Qb2awYRRyEm65a8CrafZWDOLF3xrA4cJbEHd03aO5Ode04A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

### 6、高可用方案

> 
>
> [Redis高可用方案：sentinel（哨兵模式）和集群](https://mp.weixin.qq.com/s/2LDkEMXDLAHroyr0uFb9sQ)，==这篇文章有非常具体的redis哨兵和集群配置操作==
>
> [那你再跟我说说Redis如何实现高可用吧？](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)，文章最后一个问题
>
> 1、主从复制——高可用的基础
>
> 2、==哨兵==模式，解决了**主节点故障自动切换（自动容灾恢复）**的问题;
>
> 3、==集群==，动态扩充redis，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而**提高 Redis 服务的读写性能、存储能力**
>
> - 集群中那么多Master节点，redis cluster在存储的时候如何确定选择哪个节点呢？
>
>   采用的是**类一致性哈希算法实现节点选择的**，Redis Cluster将自己分成了16384个**Slot**（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。
>
>   - 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。
>   - 再用 16bit 值对 16384 取模，得到 `0~16383` 范围内的模数，每个模数代表一个相应编号的哈希槽。
>
>   - 每个Redis节点负责处理一部分槽位，加入你有三个master节点 ABC，每个节点负责的槽位如下：
>
> | 节点 |   处理槽位    |
> | :--: | :-----------: |
> |  A   |    0-5000     |
> |  B   | 5001 - 10000  |
> |  C   | 10001 - 16383 |
>
> 

### 7、如何使用redis设计==消息队列===？

> [小林大佬的网站Redis 常见数据类型和应用场景](https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2)
>
> [Redis 消息队列三种方案（List、Streams、Pub/Sub）](https://www.jianshu.com/p/fa3531f90fe3)
>
> - [list](https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2)
>
>   > `lpush+brpop=Message Queue`**（消息队列）**，`BRPOP`命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。**和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销**。
>   >
>   > - 基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。
>   >   - 消息保序：使用 LPUSH + RPOP；
>   >   - 阻塞读取：使用 BRPOP；
>   >   - 重复消息处理：生产者自行实现全局唯一 ID；
>   >   - 消息的可靠性：使用 BRPOPLPUSH
>   > - List 作为消息队列有什么缺陷？
>   >   - **List 不支持多个消费者消费同一条消息**，因为一旦消费者**拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费**。
>   >   - **生产者需要自行实现全局唯一 ID。**
>   >   - 要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 **List 类型并不支持消费组的实现**。
>
> - [发布订阅模式`publish/subscribe`](https://www.jianshu.com/p/fa3531f90fe3)————消息多播
>
>   > 补充：Redis 发布/订阅机制为什么不可以作为消息队列？
>   >
>   > 发布订阅机制存在以下缺点，都是跟丢失数据有关：
>   >
>   > 1. 发布/订阅机制没有基于任何数据类型实现，所以**不具备「数据持久化」的能力，也就是发布/订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布/订阅机制的数据也会全部丢失。**
>   > 2. 发布订阅模式是“发后既忘”的工作模式，如果有**订阅者离线重连之后不能消费之前的历史消息**。
>   > 3. 当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 `client-output-buffer-limit pubsub 32mb 8mb 60`。
>   >
>   > 所以，发布/订阅机制只适合即使通讯的场景，比如[构建哨兵集群 (opens new window)](https://xiaolincoding.com/redis/cluster/sentinel.html#哨兵集群是如何组成的)的场景采用了发布/订阅机制
>
> - [Stream](https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-9)
>
>   > Redis Stream 是 Redis 5.0 版本新增加的数据类型，**Redis 专门为消息队列设计的数据类型**。
>   >
>   > ```shell
>   > * 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID
>   > ```
>   >
>   > **Stream 的基础方法，使用 xadd 存入消息和 xread 循环阻塞读取消息的方式可以实现简易版的消息队列**，交互流程如下图所示：
>   >
>   > ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Stream%E7%AE%80%E6%98%93.png)
>   >
>   > **特有功能**：Stream 可以以使用 **XGROUP 创建消费组**，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。
>   >
>   > - 消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即**同一个消费组里的消费者不能消费同一条消息**。
>   > - 但是，**不同消费组的消费者可以消费同一条消息**（但是**有前提条件**，创建消息组的时候，不同消费组指定了**相同位置**开始读取消息）。
>   > - 使用消费组的目的是让**组内的多个消费者共同分担读取消息**，所以，我们通常会让每个消费者读取部分消息，从而实现**消息读取负载在多个消费者间是均衡分布的**。
>   > - 消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息；
>
>   进阶问题——————在stream应用场景靠后的位置
>
>   > Redis 基于 Stream 消息队列与专业的消息队列`Kafka、RabbitMQ`有哪些差距？
>   >
>   > 1、Redis Stream 消息队列能不能保证三个环节都不丢失数据？
>   >
>   > - Redis **消息中间件会丢消息**，Redis 在以下 2 个场景下，都会导致数据丢失：
>   >   - AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能
>   >   - 主从复制也是异步的，[主从切换时，也存在丢失数据的可能 (opens new window)](https://xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-主从切换如何减少数据丢失)。
>   >
>   > <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="img" style="zoom:50%;" />
>   >
>   > 
>   >
>   > 2、Redis Stream 消息可堆积吗？
>   >
>   > Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。
>   >
>   > 3、因此，**把 Redis 当作队列来使用时，会面临的 2 个问题：**
>   >
>   > - Redis 本身可能会丢数据；
>   > - 面对消息挤压，内存资源会紧张；
>   >
>   > 所以，**能不能将 Redis 作为消息队列来使用，关键看你的业务场景**：
>   >
>   > - 如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。
>   > - 如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。

### 8、redis分布式锁

> [面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)
>
> [Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)
>
> - setnx
>   - `NX参数`通过**key不存在才能set成功的特性**加锁
>   - `set test value NX PX 3000`，加上一个超时时间，防止上锁的进程崩了，锁还没有释放，导致系统中谁拿不到锁
>   - 存在问题，如果进程A操作锁内资源**超过设置的超时时间** ，那么就会导致**其他进程B拿到锁** ，等**进程A** 回来了，回手就是把B进程的锁删了or另一个进程C加锁成功，B又删除了C，以此类推，
>   - 可以将`value`设置一个**唯一的客户端ID** ，或者用**UUID** 这种随机数。当解锁的时候，先获取value判断是否是当前进程加的锁，再去删除
>   - 在finally代码块中，**get和del并非原子操作** ，还是有进程安全问题。
>   - 删除锁的正确姿势之一，就是可以使用**lua** 脚本，就算你在**lua** 里写出花，执行也是一个命令(**eval** /**evalsha** )去执行的，一条命令没执行完，其他客户端是看不到的。
>
> - redisson
>
>   - Redisson是**java的redis客户端之一** ，提供了一些api方便操作redis。
>   - Redisson普通的锁实现源码主要是**RedissonLock** 这个类,源码中**加锁/释放锁** 操作都是用**lua** 脚本完成的，封装的非常完善;并且考虑了锁的可重入性
>
> - RedLock
>
>   - 红锁并非是一个工具，而是redis官方提出的一种分布式锁的**算法** 。
>
>   - 刚刚介绍完的redisson中，就实现了redLock版本的锁。也就是说除了**getLock** 方法，还有**getRedLock** 方法。
>
>   - <img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWOR3h70UysX22WJKgib2ymWHCCJ5yvHqI6Q4FZoMkicAwE107htKic7ntickvztjgXSNulrjXnlibHLzw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />
>
>   - 红锁算法认为，只要(N/2) + 1个节点加锁成功，那么就认为获取了锁， 解锁时将所有实例解锁。流程为：
>
>     1. 顺序向五个节点请求加锁
>     2. 根据一定的**超时时间** 来推断是不是跳过该节点
>     3. 三个节点加锁成功并且花费时间小于锁的有效期
>     4. 认定加锁成功
>
>     也就是说，假设锁**30秒** 过期，三个节点加锁花了31秒，自然是加锁失败了
>
>   - redLock算法虽然是需要多个实例，但是这些实例都是独自部署的，没有主从关系。RedLock作者指出，之所以要用独立的，是避免了redis异步复制造成的锁丢失，比如：主节点没来的及把**刚刚set进来这条数据** 给从节点，就挂了。

### 9、[如何分配客户端的请求给服务器（节点）进行处理，==一致性哈希是什么==，使用场景，解决了什么问题？](https://mp.weixin.qq.com/s/Os2JOInK5PBLBCwUzh8Jfg)

> 因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务;
>
> 要如何分配来自客户端的请求给服务器节点呢？————==负载均衡问题==
>
> 1. 最简单，引入一个中间的负载均衡层，让它将外界的请求「轮流」的转发给内部的集群；
>
> 2. 考虑到每个服务器的硬件配置有所区别，引入权重值，将硬件配置更好的节点的权重值设高，承担更多的请求————加权轮询
>
>    - 但是，加权轮询算法是无法应对「分布式系统」的，因为分布式系统中，每个节点存储的数据是不同的；当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如**一个分布式 KV（key-value缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的**，不是说任意访问一个节点都可以得到缓存结果的
>
> 3. 哈希算法
>
>    - 因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。
>    - 但是有一个很致命的问题，**如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据**，否则会出现查询不到数据的问题。假设总数据条数为 M，哈希算法在面对节点数量变化时，**最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)**，这样数据的迁移成本太高了。
>
> 4. ==一致性哈希算法==
>
>    - 与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而**一致哈希算法是对 2^32 进行取模运算，是一个固定的值**
>
>    - 把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，称为**哈希环**
>
>    - **一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上**。一致性哈希要进行两步哈希：
>
>      - 第一步：对==存储节点，即服务器==进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；
>      - 第二步：当对数据进行存储或访问时，对==数据==进行哈希映射；
>
>    - 问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？
>
>      答案是，映射的结果值往**顺时针的方向的找到第一个节点**，就是存储该数据的节点。
>
>      <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfBVIs6Vb5TC4SyIF2lPZlpicZiaN3k5SdE1PM8faH19JnXU3gVdaOibeWsr9neYrw1oB8HuU6kNn9tg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />
>
>    - **在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响**。
>
>      假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：可以看到，key-01、key-03 都不受影响，只有 key-02  需要被迁移节点 D。
>
>      <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfBVIs6Vb5TC4SyIF2lPZlpaicCl03oWJvYCWaYOlVgfS1p7GMCYIiarNM2LKNaIYcRCuWE9JzhlxTA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />
>
>    - 但是**一致性哈希算法并不保证节点能够在哈希环上分布均匀**，这样就会带来一个问题，会有大量的请求集中在一个节点上。**在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应**.**当节点 A 宕机后**，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，**节点 B 的数据量、访问量都会迅速增加很多倍**，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，**进而形成雪崩式的连锁反应**。
>
>      <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfBVIs6Vb5TC4SyIF2lPZlpewujtsNjFbESJ1OqyicBYmgYg6zo6TYIEQHP7DFKLcfYY5HOq2dH1qw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />
>
>    - **一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题**
>
> 5. 在哈希环上节点数越多，哈希环上的节点分布的就越均匀。但问题是，实际中我们没有那么多节点。所以这个时候我们就加入**虚拟节点**，也就是对一个真实节点做多个副本。具体做法是，**不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。**
>
>    - 比如对每个节点分别设置 3 个虚拟节点：
>      - 对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03
>      - 对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03
>      - 对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03
>      - <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfBVIs6Vb5TC4SyIF2lPZlpNYhYYsgEaRTNhsaYDlkGHuJCALoRwU1OOc1XoLehs72D7m8CxIXLFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />
>    - 引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍
>    - **节点数量多了后，节点在哈希环上的分布就相对均匀了**。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。
>    - 在实际的工程中，虚拟节点的数量会大很多，比如 **Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点**。
>    - 虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。==**当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高**==。
>      - 比如，**当某个节点被移除时**，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，**即这些不同的真实节点共同分担了节点变化导致的压力。**
>      - 有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如==对权重更高的节点增加更多的虚拟机节点==即可。
>    - 因此，**带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景**。

### 10、如何保证mysql数据库和redis缓存之间的数据一致性？

#### 1、[小林大佬版本](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247508038&idx=2&sn=50a5d4a4b88f9572976753562aeb1b52&chksm=f98de4eccefa6dfaf9c48451685b51a7be62f237cb5ab13efb75a83b814437a370b2f8abfa88&mpshare=1&scene=1&srcid=0719w6lFNF7CSNfjrwpFGOVl&sharer_sharetime=1658224856673&sharer_shareid=5f6c924e27776ec7fe1d58be0d66a7ac#rd)

> ##### 背景：
>
> - 在高并发的业务场景下，数据库大多情况都是用户并发访问量最薄弱的环节。所以，为了提升数据访问的性能，就需要引入 Redis 作为 MySQL 缓存层，使用redis做一个缓冲操作，让请求先让问到redis，而不是直接访问mysql等数据库。这样可以大大缓解数据库的压力。
>
> - **由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题**：
>
>   - 先更新数据库，再更新缓存；——最终数据库是2，缓存是1，不一致
>
>     <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapr2stAd0NETZpY1AnHLib0kQyKfL8PRKJEhGNjMko2OXMFyag61DPbcw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:33%;" />
>
>   - 先更新缓存，再更新数据库；——最终缓存是2，数据库为1，不一致
>
>     <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapibTMI0vHhCK0PoqFjMj2ic2w2AQZeNqNNV3moaZsOHVV6bErRibUj9p4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:33%;" />
>
>   - 这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。因为更新数据库和更新缓存这两个操作是独立的，而我们又没有对操作做任何并发控制，那么当两个线程并发更新它们的话，就会因为写入顺序的不同造成数据的不一致。
>
>     所以我们得增加一些手段来解决这个问题，这里提供两种做法：
>
>     - 在更新缓存前先加个**分布式锁**，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，**当然引入了锁后，对于写入的性能就会带来影响。**
>     - 在更新完缓存时，给缓存加上较短的**过期时间**，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。
>
> ##### 解决办法：
>
> **Cache Aside 策略**，中文是叫旁路缓存策略。——在更新数据时，不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中
>
> <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapSb8MEccpUa4ZwQSYEc1nQicQeRomsl4UWI4kqrlTRURXYcDyLjAM1eg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:33%;" />
>
> - ###### 先删除缓存，再更新数据库；
>
>   > - <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapeACSp1kd8w5cibl7veAVzNHt9nlvyaIxI6xtTTdUibwhenml3yTwD0zw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:33%;" />
>   > - 在「读B + 写A」并发的时候，最终缓存为20，数据库为21，不一致。**可以通过==延迟双删==策略解决**
>   >
>   > - ==延迟双删伪代码==
>   >
>   > ```c++
>   > #删除缓存
>   > redis.delKey(X)
>   > #更新数据库
>   > db.update(X)
>   > #睡眠
>   > Thread.sleep(N)
>   > #再删除缓存
>   > redis.delKey(X)
>   > ```
>   >
>   > - **加了个睡眠时间，主要是为了**确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。
>   > - 所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。
>   >
>   > - 但是具体睡眠多久其实是个**玄学**，很难评估出来，所以这个方案也只是**尽可能**保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。
>
> - ###### 先更新数据库，再删除缓存
>
>   > <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapiaHwGD4OYARxHTUqRctZyWPyEsGeiaMTWvjDS42t0zsI8Qk2eicdntySw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:33%;" />
>   >
>   > - 理论分析，虽然最终缓存与数据库不一致，**但是在实际中，这个问题出现的概率并不高，因为缓存的写入通常要远远快于数据库的写入**，所以下图请求A“将20回写缓存”会早于请求B“删除缓存”之前完成，于是请求B最终将请求A的"缓存的20"删除掉。
>   >
>   > - 所以，**「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的**。再给缓存数据加上了「**过期时间**」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。==实际业务中常用这个==。
>   >
>   > - **但是一旦第二个删除缓存操作失败**，导致缓存中是旧值，数据库中是新值。其实不管是先操作数据库，还是先操作缓存，==**只要第二个操作失败**==都会出现数据不一致的问题。解决办法：
>   >
>   >   - ==**重试机制**。==
>   >
>   >     > 我们可以引入==**消息队列**==，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。
>   >     >
>   >     > - 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
>   >     > - 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。
>   >     >
>   >     > 举个例子，来说明重试机制的过程。
>   >     >
>   >     > <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapCywtF9Hgn5M0GX4Q00fz2BchofGYmQ3FOXu3JAyGPXKmRzZoXvxUqw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />
>   >
>   >   - ==订阅 MySQL binlog，再操作缓存==
>   >
>   >     > 「**先更新数据库，再删缓存**」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。
>   >     >
>   >     > 于是我们就可以**通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，==阿里巴巴开源的 Canal 中间件==就是基于这个实现的**。
>   >     >
>   >     > Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。
>   >     >
>   >     > 下图是 Canal 的工作原理：
>   >     >
>   >     > <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiap8pUHyDL1LXcv0NzFswFhEkliaD26ENzGdcLKoIiaWIDD2iaUHLFCK89iaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />

#### 2、[网络版本——也是好文章](https://www.cnblogs.com/shier-dong/p/15347134.html)

> 也是一片好文章，详细介绍了延迟双删的两种策略、双删失败怎么办、主动加载的问题和解决办法
>
> 1.懒加载模式缓存可以采用**延迟双删**（先删除缓存，再写数据库，==休眠一定时间==/==异步串行写入mq==，再次删除缓存）+**TTL(设置缓存过期时间)失效**来实现
>
> 2.双删失败情况下可采取重试机制，重试又**业务通过MQ重试**以及**组件消费mysql的binlog再写入MQ重试**两种方式
>
> 3.主动加载由于操作本身不具有幂等性，所以需要考虑加载的有序性问题，采取MQ的分区机制实现串行化处理，实现缓存和mysql数据的最终一致性，此时读和写操作的缓存加载事件是走的同一个MQ。



---

## 七、MySQL

> [MySQL数据库精选60道面试题——有目录，更深一点，好文章](https://blog.csdn.net/qq_46494427/article/details/124154077)
>
> [==MySQL 经典 38 问！==](https://mp.weixin.qq.com/s/FyN3bLo7LFz3aX31kI13yQ)————————好文章
>
> - 事务的四大特性？
>
> - 事务隔离级别有哪些？
>
> - 索引
>
> - - 什么是索引？
>   - 索引的优缺点？
>   - 索引的作用？
>   - 什么情况下需要建索引？
>   - 什么情况下不建索引？
>   - 索引的数据结构
>   - Hash 索引和 B+ 树索引的区别？
>   - 为什么 B+ 树比 B 树更适合实现数据库索引？
>   - 索引有什么分类？
>   - 什么是最左匹配原则？
>   - 什么是聚集索引？
>   - 什么是覆盖索引？
>   - 索引的设计原则？
>   - 索引什么时候会失效？
>   - 什么是前缀索引？
>
> - 常见的存储引擎有哪些？
>
> - MyISAM 和 InnoDB 的区别？
>
> - MVCC 实现原理？
>
> - 快照读和当前读
>
> - 共享锁和排他锁
>
> - 大表怎么优化？
>
> - bin log / redo log / undo log
>
> - bin log 和 redo log 有什么区别？
>
> - 讲一下 MySQL 架构？
>
> - 分库分表
>
> - 什么是分区表？
>
> - 分区表类型
>
> - 查询语句执行流程？
>
> - 更新语句执行过程？
>
> - exist 和 in 的区别？
>
> - truncate、delete 与 drop 区别？
>
> - having 和 where 的区别？
>
> - 什么是 MySQL 主从同步？
>
> - 为什么要做主从同步？
>
> - 乐观锁和悲观锁是什么？
>
> - 用过 processlist 吗？
>
> [MySQL相关问题整理](https://zyfcodes.blog.csdn.net/article/details/105361002)
>
> [小林——告别 MVCC!](https://mp.weixin.qq.com/s/lbh7tJIANFsYRi_xfCpwJg)
>
> [高质量面经——面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

### 1、索引相关

> [别再说不懂索引了](https://mp.weixin.qq.com/s/LTX67XxkWcAeYUyLh_5b4g)——小林
>
> [MySQL 经典 38 问！](https://mp.weixin.qq.com/s/FyN3bLo7LFz3aX31kI13yQ) ————前面的索引部分详细且容易理解
>
> 索引在哪些场景下会失效？
>
> > - \1. 查询条件包含or，可能导致索引失效
> > - \2. 如何字段类型是字符串，where时一定用引号``括起来，若没有使用引号，可能会因为类型不同发生隐式转换，使索引失效
> > - \3. like通配符可能导致索引失效。
> >   - 以 % 开头的 like 查询如`%abc`，无法使用索引；
> >   - 非 % 开头的 like 查询如`abc%`，相当于范围查询，会使用索引
> > - \4. 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
> > - \5. 在索引列上使用mysql的内置函数，索引失效。
> > - \6. 对索引列运算（如，+、-、*、/），索引失效。
> > - \7. 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
> > - \8. 索引字段上使用is null， is not null，可能导致索引失效。
> > - \9. 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
> > - \10. mysql估计使用全表扫描要比使用索引快,则不使用索引。



### 2、多表查询————内链接、左联结、右联结的区别

> - **内连接：显示左边右边共有的**
>
>   ```mysql
>   隐式内连接：使用where条件消除无用数据
>   -- 查询员工表emp的名称，性别。部门表dept的名称
>   SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id    
>   
>   显式内连接：(inner可以省略)
>   语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
>   例如： SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;
>   ```
>
> - 左外连接的定义：**左边有的，右边没有的为null**，是以左表为基础，根据ON后给出的两表的条件将两表连接起来。结果会将左表所有的查询信息列出，而右表只列出ON后条件与左表满足的部分。左连接全称为左外连接，是外连接的一种。
>
> ```mysql
> * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；(outer可以省略不写)
> * 查询的是左表所有数据以及其交集部分。
> * 例子：
> 	-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
> 	SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;
> ```
>
> - 右外连接与左连接相反
> - 子查询
>
> ```mysql
> * 概念：查询中嵌套查询，称嵌套查询为子查询。
> -- 一条sql就可以完成-- 查询工资最高的员工信息
> SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);
> * 子查询不同情况
> 			1. 子查询的结果是单行单列的：
> 				* 子查询可以作为条件，使用运算符去判断。 运算符： > >= < <= =
> 				* 
> 				-- 查询员工工资小于平均工资的人
> 				SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp);
> 			2. 子查询的结果是多行单列的：
> 				* 子查询可以作为条件，使用运算符in来判断
> 				-- 查询'财务部'和'市场部'所有的员工信息
> 				SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';
> 				SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
> 				-- 子查询
> 				SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');
> 
> 			3. 子查询的结果是多行多列的：
> 				* 子查询可以作为一张虚拟表参与查询
> 				-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
> 				-- 子查询
> 				SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2
> 				WHERE t1.id = t2.dept_id;
> 				
> 				-- 普通内连接
> 				SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  '2011-11-11'
> ```

### 3、[如何解决MySQL中的死锁问题？](https://mp.weixin.qq.com/s/urZCVeEYkbrYr_cu--fgkg)



### 4、[mysql的锁🔒](https://mp.weixin.qq.com/s/ptCOFqSuMBHm_4OmFPV2dg)

#### 4-1、共享锁与排它锁

> **SELECT 的读取锁定**主要分为两种方式：共享锁`lock in share mode`和排他锁`for update`。
>
> ```mysql
> select * from table where id<6 lock in share mode;--共享锁
> select * from table where id<6 for update;--排他锁
> ```
>
> - 这两种方式主要的不同在于：**使用共享锁多个事务同时更新同一个表单时很容易造成死锁。**
>
> - **申请排他锁的前提是**：没有线程对该结果集的任何行数据使用排他锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL 会对查询结果集的每行数据添加排他锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被`commit`语句或`rollback`语句结束为止。
>
> -  使用排他锁注意事项：
>
> 1. `for update` 仅适用于 innodb，且必须在事务范围内才能生效。
> 2. 根据主键进行查询，查询条件为`like`或者不等于，主键字段产生**表锁**。
> 3. 根据非索引字段进行查询，会产生**表锁**。

#### 4-2、表锁和行锁

> 按照对数据操作的粒度分
>
> ##### 表锁
>
> - 每次操作锁住整张表。
> - 开销小（不需要定位到某个元素，只需要定位到表），加锁快；
> - 不会出现死锁；
> - 锁定粒度大，发生锁冲突的概率最高，并发度最低；
> - 一般用在整表数据迁移的场景。
> - 表锁的操作方式
>   - 手动增加表锁：lock table 表名称 read(write),表名称2 read(write);
>   - 查看表上加过的锁 show open tables;
>   - 删除表锁 unlock tables;
>
> ##### 行锁
>
> - 每次操作锁住一行数据。
> - 开销大，加锁慢；
> - 会出现死锁；
> - 锁定粒度最小，发生锁冲突的概率最低，并发度高。
> - InnoDB与MYISAM的最大不同点：InnoDB支持行级锁、支持事务
> - MyISAM在执行查询语句SELECT前，会自动给涉及的所有**表**加读锁,在执行update、insert、delete操作会自动给涉及的**表**加写锁。
> - InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。
> - 行锁操作方式：
>   - sql后增加for update来实现行锁。
>   - for update在不走索引的时候会锁表！但是当要修改或者查询的数据不存在的时候，不会锁表，也不会锁定行！

#### 4-3、读锁和写锁

> 读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞

#### 4-4、乐观锁和悲观锁

> ##### 乐观锁
>
> - 乐观锁时会假设在极大多数情况下不会形成冲突，只有在数据提交的时候，才会对数据是否产生冲突进行检验。发生冲突后，不修改数据
> - 实现方式：在数据库表中增加一列，记为version，当我们将数据读出时，将版本号一并读出，当数据进行更新时，会对这个版本号进行加1，当我们提交数据时，会判断数据库表中当前的version列值和当时读出的version是否相同，若相同说明没有进行更新的操作，不然，则取消这次的操作。乐观锁一般使用版本号机制或CAS算法实现。
>
> ##### 悲观锁
>
> - MySql的悲观锁就是打开事务，当启动事务时，如果事务中的sql语句涉及到索引并用索引进行了条件判断，那么会使用行级锁锁定所要修改的行，否则使用表锁锁住整张表。
> - 悲观锁：假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。
> - 实现方式
>   - sql后增加for update来实现悲观锁。
>   - for update在不走索引的时候会锁表！
>   - 当要修改或者查询的数据不存在的时候，不会锁表，也不会锁定行！
> - 当InnoDB表有多个索引的时候,不同事务使用不同的索引去锁定同一条记录是怎么处理的？
>   - 虽然用的不同辅助索引，但是相应的聚簇索引也会加锁，也就是主键会加锁，这样就防止并发修改了

#### 4-5、间隙锁与临键锁

> 下面在rr隔离级别下，解决当前读的幻读问题，会介绍这两种锁
>
> - 间隙锁`gap lock`，锁的就是两个值之间的空隙。
>   - 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样
>   - 产生条件
>     - 使用普通索引锁定；
>     - 使用多列唯一索引；
>     - 使用唯一索引锁定多行记录。
>
> - 临键锁`Next-key lock`，行锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间



### 5、[MySQL主从复制原理以及过程以及用到的三个重要线程](https://blog.csdn.net/jiayoudangdang/article/details/123167600)

> MySQL主从复制工作原理:
>
> Binary log：主数据库的二进制日志；
> Relay log：从服务器的中继日志；
>
> 基本原理流程：
>
> - 在主库上把数据更新记录到二进制日志；
> - 从库将主库的日志复制到自己的中继日志；
> - 从库读取中继日志的事件，将其重放/同步到从库数据中，
>
> **3个线程以及之间的关联：**
> `主：binlog线程`——记录下所有改变了数据库数据的语句，放进master上的 binlog中；
> `从：io线程`——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；
> `从：sql执行线程`——执行relay log中的语句；
>
> **MySQL主从复制过程：**
>
> - 第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到 binlog文件中。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。
> - 第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程终的目的是将这些事件写入到中继日志中。
> - 第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。
>
> 由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念：
>
> - 全同步复制：
>   主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
> - 半同步复制：
>   与全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。
>
> **为什么要做主从同步？**
>
> 1. 读写分离，使数据库能支撑更大的并发。
> 2. 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。
> 3. 数据备份，保证数据的安全。

### 6、慢查询

> 是指在Mysql中执行时间超过指定阈值的语句将被记录到慢查询文件中
>
>  [你好，面试官 | 分析一下SQL执行慢的原因？如何排查，优化思路？（加餐篇）](https://mp.weixin.qq.com/s/XtjVp363Rev6EBHRzPtbhA))



### 7、[MySQL解决幻读——MVCC与临键锁](https://blog.csdn.net/QAQ123666/article/details/105084758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164792119816780265410477%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164792119816780265410477&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-105084758.142^v3^pc_search_result_cache,143^v4^control&utm_term=mvcc%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB&spm=1018.2226.3001.4187)

#### 7-1、快照读与当前读

> - 快照读：读取的是快照版本，即快照读可能读到的不一定是数据的最新版本，而有可能是之前的历史版本
>   - 不加锁的普通查询select操作，通过 mvcc 来进行并发控制的，不用加锁。
>
> - 当前读：读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。比如：
>   - select...lock in share mode (共享读锁) 
>   - select...for update（行级锁）
>   - update , delete , insert
>
> - **在RR级别下，==快照读/普通读==是通过[MVVC(多版本控制)+undo log](https://blog.csdn.net/weixin_45325628/article/details/123292887?spm=1001.2014.3001.5502)来实现的，==当前读==是通过加record lock(记录锁/行锁)和gap lock(间隙锁)来实现的。**
>
> - **mvcc的优势是不加锁，并发性高，缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。**
>
> - **快照读的幻读是用MVCC解决的，当前读的幻读是用临键锁next-key解决的。**



#### 7-2、MVCC实现原理

> MVCC(`Multiversion concurrency control`) ——多版本并发控制，就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过==版本链==和==快照`read view`==找到对应版本的数据。
>
> 作用：提升并发性能。对于高并发场景，MVCC 比行级锁开销更小。
>
> **MVCC 实现原理如下：**
>
> ##### 一、版本链
>
> MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。
>
> - `DB_ROW_ID`：==主键==，如果数据表没有主键，InnoDB 会自动生成主键。
>
> - `DB_TRX_ID`：==当前事务 id==，通过事务 id 的大小判断事务的时间顺序。
> - `DB_ROLL_PRT`：==回滚指针==，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成`undo log`版本链。
>
> 每条表记录大概是这样的：
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJYpKOmmbtIv3iaja2qg9ibh1Z14eaYmJCAQXxpPfGvZoBgLJfvX4gp2voS0NCb9xyYfItGuAbMsv4NA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1&retryload=1)
>
> 使用事务更新行记录的时候，就会**生成版本链，执行过程如下**：
>
> 1. 用排他锁锁住该行；
> 2. 将该行原本的值拷贝到`undo log`，作为旧版本用于回滚；
> 3. 修改当前行的值，生成一个新版本，更新事务 id，使回滚指针指向旧版本的记录，这样就形成一条版本链。
>
> 下面举个例子方便大家理解。
>
> 1. 初始数据如下，其中`DB_TRX_ID`和`DB_ROLL_PTR`为空。
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJYpKOmmbtIv3iaja2qg9ibh1Z6Esj2ea9tmEyTmrYJrb2zdqW6HKc7daZEjBYkYQfLvJ5dHg1DpwIgA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1&retryload=1)
>
> 2. 事务A对该行数据做了修改，将`age`修改为 12，效果如下：
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJYpKOmmbtIv3iaja2qg9ibh1Z2ic2Oib4WmlqjC7NcgmjQmEAcBqECXAAmlKZqm0j3gOCet1nmCiatcUibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
>
> 3. 之后事务B也对该行记录做了修改，将`age`修改为 8，效果如下：
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJYpKOmmbtIv3iaja2qg9ibh1ZicnBH6JJjVn3XXE0F2Fb8QNJ8YHoFXMuJpcOptdhlWSeN44Kzwfr4GA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
>
> 4. 此时 undo log 有两行记录，并且通过回滚指针连在一起。
>
> ##### 二、快照 read view 的原理。
>
> - `read view`可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取**某时刻 t** 的数据时，到 t 时间点拍的“照片”上取数据。会对数据在每个时刻的状态拍成照片记录下来。那么**之后获取某时刻的数据时就还是原来的照片上的数据，是不会变的**。**其实也可以简单理解为是一个版本链的集合，只不过在这里的版本链是经过筛选的。**
>
> - 在`read view`内部维护一个==活跃事务链表==，表示生成`read view`的时候还在活跃的事务。这个链表**包含**在创建`read view`**之前还未提交**的事务，**不包含**创建`read view`**之后提交**的事务。即这个链表表示此时还在活跃的事务，指的是那些在当前快照中还未提交的事务，新建事务(当前事务)与正在内存中commit 的事务不在活跃事务链表。
>
> - 不同隔离级别创建 read view 的时机不同。
>   - read committed：每次执行 select 都会创建新的 read_view，保证能读取到其他事务已经提交的修改。
>   - ==repeatable read==：在一个事务范围内，第一次 select 时更新这个 read_view，以后不会再更新，后续所有的 select 都是复用之前的 read_view。这样==可以保证事务范围内每次读取的内容都一样，即可重复读。==
>
> - read_view中不会显示所有的数据行，**只会显示“可见”的记录**，**read view 的记录筛选方式**：
>   - **前提**：`DATA_TRX_ID` 表示每个数据行的**最新的事务 ID**；`up_limit_id`表示**当前快照**中的最先开始的事务；`low_limit_id`表示当前快照中的最慢开始的事务，即最后一个事务。
>
> <img src="C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220716195552463.png" alt="image-20220716195552463" style="zoom:67%;" />
>
> - 如果`DATA_TRX_ID` **<** `up_limit_id`：说明在创建`read view`时，修改该数据行的事务已提交，该版本的记录***可被当前事务读取到***。
>
> - 如果`DATA_TRX_ID` **>=** `low_limit_id`：说明当前版本的记录的事务是在创建`read view`之后生成的，该版本的数据行***不可以被当前事务访问***。此时**需要通过版本链找到上一个版本**，然后重新判断该版本的记录对当前事务的可见性。
>
> - 如果`up_limit_id` **<=** `DATA_TRX_ID` **<** `low_limit_i`：
>
> - 1. 需要**在活跃事务链表中查找是否存在 ID** 为`DATA_TRX_ID`的值的事务。
>   2. 如果存在，因为在活跃事务链表中的事务是未提交的，所以该记录是不可见的。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。
>   3. 如果不存在，说明事务 trx_id 已经提交了，这行记录是可见的。
>
> **总结**：`InnoDB` 的`MVCC`是通过 `read view` 和版本链实现的，**版本链保存有历史版本记录，通过`read view` 判断当前版本的数据是否可见**，==如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。==快照读情况下，InnoDB 通过`mvcc`机制避免了幻读现象。而`mvcc`机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。

#### 7-3、临键锁

> [在RR级别下，mysql通过间隙锁可以防止幻读——插入](https://blog.csdn.net/m0_37556444/article/details/104479489)
>
> - **当前读的幻读与解决方式：临键锁next-key locks = 行锁+间隙锁**，在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。select * from table where id>3 锁住的就是id=3这条记录以及id>3这个区间范围，锁住索引记录之间的范围，避免范围间**插入**记录，以避免**产生幻影行**记录；
>   - `行锁Record Lock`：锁直接加在索引记录上面。
>   - `间隙锁Gap Lock`：是加在索引之间的锁， Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。
>   - `Next-Key Lock ：Record Lock + Gap Lock`，锁定一个范围并且锁定记录本身 。
>
> - innodb自动使用间隙锁的条件：
>   - （1）必须在RR级别下（**解决幻读**）。`Serializable`隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。
>   - （2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）

### 8、[执行一条SQL语句，期间发生了什么？]()

> #### 1、`MySQL`架构
>
> <img src="C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220716224422739.png" alt="image-20220716224422739" style="zoom:67%;" />
>
> MySQL 主要分为 Server 层和存储引擎层：
>
> - **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
> - **存储引擎**：主要负责数据的存储和读取。server 层通过 api 与存储引擎进行通信。
>
> **Server 层基本组件**
>
> - **连接器：**当客户端连接 MySQL 时，server 层会对其进行身份认证和权限校验。
> - **查询缓存:** 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。
> - **分析器:** 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。
> - **优化器：** 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。
> - **执行器：** 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。
>
> #### 2、查询语句执行流程？
>
> - 查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。
>
> - 举个例子，查询语句如下：
>
> ```mysql
> select * from user where id > 1 and name = '大彬';
> ```
>
> 1. 首先检查权限，没有权限则返回错误；
> 2. MySQL8.0 以前会查询缓存，缓存命中则直接返回，没有则执行下一步；
> 3. 词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；
> 4. 两种执行方案，先查 `id > 1` 还是 `name = '大彬'`，优化器根据自己的优化算法选择执行效率最好的方案；
> 5. 校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。
>
> #### 3、**更新语句执行过程？**
>
> - 更新语句执行流程如下：分析器、权限校验、执行器、引擎、`redo log`（`prepare`状态）、`binlog`、`redo log`（`commit`状态）。——————**redo log是innodb存储引擎级别，binlog是mysql数据库级别的文件**
>
> 举个例子，更新语句如下：
>
> ```mysql
> update user set name = '大彬' where id = 1;
> ```
>
> 1. 先查询到 id 为 1 的记录，有缓存会使用缓存。
> 2. 拿到查询结果，将 name 更新为大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录`redo log`，此时`redo log`进入 `prepare`状态。
> 3. 执行器收到通知后记录`binlog`，然后调用引擎接口，提交`redo log`为`commit`状态。
> 4. 更新完成。
>
> - 为什么记录完`redo log`，不直接提交，而是先进入`prepare`状态？
>   - 假设先写`redo log`直接提交，然后写`binlog`，写完`redo log`后，机器挂了，`binlog`日志没有被写入，那么机器重启后，这台机器会通过`redo log`恢复数据，**但是这个时候`binlog`并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。**

### 9、mysql其他

####  9-1、mysql中忘记了root用户的密码？

```mysql
1. cmd -- > net stop mysql 停止mysql服务
* 需要管理员运行该cmd

2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
4. use mysql;
5. update user set password = password('你的新密码') where user = 'root';
6. 关闭两个窗口
7. 打开任务管理器，手动结束mysqld.exe 的进程
8. 启动mysql服务
9. 使用新密码登录。		
```

#### 9-2、mysql如何判断事务是否提交了？

> 比较事务版本号，mysql系统会有一个系统版本号，当每开启一个事务，mysql里有一个事务列表就会添加一个版本号，查看一个事务的版本号和列表中版本的关系来判断，该事务是否提交

#### 9-3、三种日志

> MySQL 日志主要包括查询日志、慢查询日志、事务日志、错误日志、二进制日志等。其中比较重要的是 `bin log`（二进制日志）和 `redo log`（重做日志）和 `undo log`（回滚日志）。
>
> **bin log**
>
> `bin log`是 MySQL 数据库级别的文件，记录对 MySQL 数据库执行修改的所有操作，不会记录 select 和 show 语句，主要用于恢复数据库和同步数据库。
>
> **redo log**
>
> `redo log`是 innodb 引擎级别，用来记录 innodb 存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障，innoDB 存储引擎会使用`redo log`恢复到发生故障前的时刻，以此来保证数据的完整性。将参数`innodb_flush_log_at_tx_commit`设置为 1，那么在执行 commit 时会将`redo log`同步写到磁盘。
>
> **undo log**
>
> 除了记录`redo log`外，当进行数据修改时还会记录`undo log`，`undo log`用于数据的撤回操作，它保留了记录修改前的内容。通过`undo log`可以实现事务回滚，并且可以根据`undo log`回溯到某个特定的版本的数据，**实现MVCC**。

---

## 八、分布式加分项

了解分布式系统设计与开发、负载均衡技术、系统容灾，高可用系统等知识；

CAS和ABA问题

**==对分布式的了解？==**

首先说一下cap和base理论，然后往分布式锁、负载均衡、redis集群高可用，去主动靠

目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。**分布式的CAP理论**告诉我们“任何一个分布式系统都无法同时满足**一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）**，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要**牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性**”，只要这个最终时间是在用户可以接受的范围内即可。

> **CAP**
>
> CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
>
> - 一致性C：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
> - 可用性A：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
> - 分区容忍性P：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

> **BASE理论**
>
> BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
>
> - Basically Available（基本可用）
> - Soft state（软状态）
> - Eventually consistent（最终一致性）

- 分布式系统设计与开发
  - 分布式缓存
  - 分布式锁
    - [面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)
    - [Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)
- 分布式事务(解决方案)
- 负载均衡技术（在nginx服务器中配了3个tomcat服务器，每个tomcat服务器上都部署了整个系统，那么当请求数大的时候，可以分发到不同的tomcat。）
- 一致性哈希算法：很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。
  - 哈希环（通过虚拟节点提高均衡度）、redis哈希槽
- 系统容灾技术————mysql主从复制，redis持久化，哨兵监控、主复制写，从负责读
- 高可用系统————主从复制、哨兵监控（自动故障转移、恢复），集群（扩展单一服务器写能力和存储能力不足）

---

## 场景题

#### 1. [Bitmap有什么用大量数据的快速排序、查找、去重](https://www.cnblogs.com/cjsblog/p/11613708.html)

#### 2.10亿个数字，内存限制100M，进行排序

>  分治法：拆分小文件，先对每个小文件进行排序，然后使用小顶堆或大顶堆合并文件

#### 3.30亿数据下怎么去重，内存限制1G

> 方法一：
>
> 取数据（比如字符串，QQ号）的前n位做一个哈希，然后把哈希值一样的数据串放到一个文件里面。然后每次将一个文件load到内存中，然后对这个文件中的数据做个排序 or 哈希去重即可。借助hash算法思想，把一个大文件哈希分割到多个小文件中，而哈希冲突的数字一定会在同一个小文件中，从而保证了子问题的独立性，然后就可以单独对小文件通过快速排序来去重——这样就通过分而治之解决了几G数据进行内排序的问题。虽然哈希分割文件是O(n)的时间复杂度，但总的效率仍是依从快速排序的时间复杂度O(logn)。另外，分而治之有个好处就是借助子问题的独立性可以利用多核来做并行处理，甚至做分布式处理。这样的缺点是磁盘IO较多。
>
> 方法二：位图bitmap
>
> [腾讯三面：40亿个QQ号码如何去重?](https://blog.csdn.net/cainiao_python/article/details/121782198?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7.pc_relevant_default&utm_relevant_index=12)

#### 3.[如何保证mysql和redis的数据一致性？](https://www.cnblogs.com/shier-dong/p/15347134.html)

---

## 刷题

- 面试题16.10 生存人数（求多个区间的最大重合数量，及其对应的区间）——前缀和

- 数组中的第K个最大元素——快排

- 有序数组删除重复数字

- 给出0和1构成的二维数组，找出全部由0或者1构成的正方形边的最大值，——动态规划==[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)==

- [[380. O(1) 时间插入、删除和获取随机元素]](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/solution/chang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-j/)

  - 动态数组存储插入元素，哈希表存储元素在数组中的索引位置
  - 删除元素，首先判断是否在哈希表中，若存在，找到其索引`curInd`，在数组中交换索引`curInd`与`len-1`对应的值，将交换后的数组末尾元素删除，将其在哈希表中的索引也删除，同时更新原来末尾元素在哈希表中的索引为`curIdx`
  - 返回随机元素，`return nums(rand() % len);`

- [719找出第k小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

  - 双指针+二分法

  - 类似于————第k小的子数组和

    ```c++
    // 保证数组元素均为>= 0
    #include <bits/stdc++.h>
    using namespace std;
    int check(vector<int> &nums, int mid) { // 双指针法求小于等于mid的连续子数组个数
        int res = 0;
        int i = 0;
        int preSum = 0;
        for (int j = 0; j < nums.size(); j++) {
            preSum += nums[j];
            while (preSum > mid) { // 不必限制i <= j
                preSum -= nums[i];
                i++;
            }
            res += j - i + 1; // [i, j]可以组成(i)/(i,i+1)/(i,i+2)...(i,j-1)/(i,j)共i - j + 1个连续子数组
        }
    }
    int num_k_less_sum(vector<int> &nums, int k) { // 二分法求第k小的子数组和
        int l = 0, r = 1e9, mid, ans; // l为可能存在的最小数组和，r为最大
        while (l <= r) {
            mid = (l + r) >> 1;
            if (check(nums, mid) >= k) { // 子数组和小于等于mid的个数多于k个，说明r过大，需要缩小 
    			r = mid - 1;
                ans = mid; // 记录结果
            } 
            else {
                l = mid + 1;
            }
        }
        return ans;
    }
    int main() {
        int n, k;
        cin >> n >> k;
        vector<int> nums(n, 0);
        for (int i = 0; i < n; i++) {
            int num;
            cin >> num;
            nums[i] = num;
        }
        cout << num_k_less_sum(nums, k) << endl;
    }
    ```


- [694 不同岛屿（形状不同）的数量](https://blog.csdn.net/weixin_44171872/article/details/109014435)

  ```C++
  class solution {
  public:
      int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1}; // 上下左右
      int numDistinctIslands(vector<vector<int>>& grid) {
          set<vector<int>> st; // 该set集合中的元素vector是某个岛屿相对其左上角的坐标
          for (int i = 0; i < grid.size(); i++) {
              for (int j = 0; j < grid[0].size(); j++) {
                  if (grid[i][j] == 1) { // 发现岛屿的左上角节点(i,j)
                      queue<int> q; // BFS用
                      vector<int> cur; // 存储当前岛屿相对于grid[i][j]的坐标
                      q.push(i);
                      q.push(j);
                      grid[i][j] = 0; // 标记
                      while (!q.empty()){
                          int x = q.front();
                          q.pop();
                          int y = q.front();
                          q.pop();
                          // 将偏移节点坐标插入cur
                          cur.push_back(x - i);
                          cur.push_back(y - j);
                          for (int k = 0; k < 4; k++) { // bfs遍历
                          	int ni = x + dx[k], nj = y + dy[k];
                          	if (ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size() && grid[ni][nj] == 1) {
                              	grid[ni][nj] == 0; // 标记
                                  q.push(ni);
                                  q.push(nj);
                          	}
                      	}
                      }
                      st.insert(cur); // 将当前岛屿的形状坐标vector插入set中，形状相同的岛屿vector<int> cur也相同，set会自动去重
                  }
              }
          }
          return st.size(); // set集合的大小就是不同形状岛屿的数量
      }
  }
  ```




---

### 其他



**虚拟化**可以将一台主机划分为多个操作系统，每个操作系统还有独立的cpu资源，存储资源，内存资源。充分的利用的硬件资源。我知道的虚拟化产品：vmware 、MS

常见的几种**dos攻击**

答：tcp syn泛洪 ，ping泛洪，udp泛洪等等

DNS劫持是什么？

>  DNS是指将网页域名翻译为对应的IP的一种方法。DNS劫持指攻击者篡改结果，使用户对域名的解析IP变成了另一个IP。

> 3.20深信服C++开发工程师电话面：
>
> 用过哪些redis数据结构（使用场景），查看端口号命令、 iptables，docker，讲一讲项目中遇到的困难（具体），怎么解决的，登录解密的密钥，分组加密，长连接：超时时间、真正的长连接、学习go和python

[**倒排索引(Inverted Index)**](https://blog.csdn.net/hguisu/article/details/7962350?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164791892916782089327763%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164791892916782089327763&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-7962350.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。

[面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

> 1. 排序链表
>
> 2. 对称与非对称加密算法的区别
>
> 3. TCP如何保证可靠性
>
> 4. 聊聊五种IO模型
>
>    5. hystrix 工作原理
>
> 5. 延时场景处理
>
> 6. https请求过程
>
> 7. **聊聊事务隔离级别，以及可重复读实现原理**
>
> 8. 聊聊索引在哪些场景下会失效？
>
> 9. 什么是虚拟内存
>
> 10. 排行榜的实现，比如高考成绩排序
>
> 11. 分布式锁实现
>
> 12. 聊聊零拷贝
>
> 13. 聊聊synchronized
>
> 14. 分布式ID生成方案

MFC（Microsoft Foundation Classes，[微软]()基础类库）：是[微软]()公司实现的一个[c++]()类库，主要封装了大部分的windows API（Application Programming Interface）函数，并且包含一个应用程序框架，以减少应用程序开发人员工作量。

作者：三锤
链接：https://www.nowcoder.com/discuss/292489?channel=-1&source_id=profile_follow_post_nctrack
来源：牛客网

5、Float型数据与0是否相等：float型： 占4字节，7位有效数字；double型：占8字节，15～16位有效数字。浮点数的表示是不精确的，float和double都不能保证可以把所有实数都准确的保存在计算机中，所以不能直接比较两个数是否完全相等。一般都是在允许的某个范围内认为某个个浮点数相等，如有两个浮点数a、b，允许的误差范围为1e-6，则abs(a-b) <= 1e-6，即可认为a和b相等。

4.3计划

- [ ] 实验工件的设计

- [ ] 


重写与重载，隐藏的区别：

> 重写：发生在子类和父类之间，当子类继承父类中的方法时，子类中的方法与父类方法的名称，参数个数，参数类型完全一致时，称子类重写了父类的方法。
> 重载：一个类中的多个方法的名称相同，参数个数或者参数类型不同，则称为重载方法
> 覆盖：子类重新实现了父类的方法，而隐藏只是把父类中的方法藏了起来，通过父类的引用来调用这个方法的时候，这个被隐藏

