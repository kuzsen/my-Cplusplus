## 我的八股文

1. 快排，时间复杂度为`O(nlog2n)`，空间复杂度为`O(log2n)`;

2. 常见的I/O编程框架

   对比几个常见的I/O编程框架：libevent，libev，libuv，aio，boost.Asio。

   libevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。
   设计模式 ：libevent为Reactor模式；
   层次架构：livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务；
   可移植性 ：libevent主要支持linux平台，freebsd平台，其他平台下通过select模型进行支持，效率不是太高；
   事件分派处理 ：libevent基于注册的事件回调函数来实现事件分发；
   涉及范围 ：libevent只提供了简单的网络API的封装，线程池，内存池，递归锁等均需要自己实现；
   线程调度 ：libevent的线程调度需要自己来注册不同的事件句柄；
   发布方式 ：libevent为开源免费的，一般编译为静态库进行使用；
   开发难度 ：基于libevent开发应用，相对容易，具体可以参考memcached这个开源的应用，里面使用了 libevent这个库。

3. linux命令`|`是无名管道，linux命令`mkfifo`是==命名管道==

C++中虚函数是说白了就是父类定义为虚函数（关键词Virtual）并实现，子类可以继承函数名并重新实现函数过程，这样子类对象调用虚函数时就调到了自己实现的函数体里，跟父类没有关系了（当然可以用[父类名::虚函数名]来调用父类虚函数实现方法），这就实现了多态性。
纯虚函数不同的是父类绝对不能实现，且不能实例化，子类必须实现父类定义的虚函数接口，除非它也想成为抽象类，抽象类可以有部分方法实现，但至少要有一个纯虚函数的类才能叫抽象类。

```c++
Class B
{
public:
    virtual void fun1(){ cout << "fun1";} //虚函数，子类不用声明或实现
    virtual void fun2 = 0; //纯虚函数，子类必须声明并实现
};
```

## 虚函数Virtual Member Functions

每个声明了虚函数或者继承了有虚函数的类，都会有一个自己的==虚函数表vtbl==。同时该类的每个对象都会包含一个==虚指针vptr==去指向该`vtbl`。虚函数按照其声明顺序放于 `vtbl` 表中, `vtbl` 数组中的每一个元素对应一个函数指针。如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置。在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中.

如果 `normalize()`是一个 `virtual member function`，那么调用：**`ptr->normalize();`**

实际上会被编译器转化为：**`(*ptr->vptr[1])(ptr);`**

- `vptr` 是指向虚函数表的指针
- `1` 是表中该函数的索引，
- `ptr` 表示的是`this`指针

一个类只有一个虚函数表，每个表中可能含有三种类型的虚函数：

- 此类定义的函数实例。包括重写了父类中的虚函数
- 从父类中继承的且没有重写的虚函数
- 纯虚函数

#### **内联函数、构造函数、静态成员函数、模板函数可以是虚函数吗?**

对于虚函数有几点关键点：

- 虚函数是属于对象的
- 虚函数的和运行时期有关

由以上两点，可以回答原问题。

- `inline`：`inline` 需要在编译期就确定类的信息，但是虚函数具体是属于哪个类的，只有在动态运行时才能知道。
- `static`：静态函数是没有 `this` 指针，而虚函数是属于某个对象的`this`与`vptr`来调用的。
- `constructor`：虚函数等到运行时才知道是调用了哪个对象的虚函数。如果构造器也是虚函数，对象都无法构建。因此，构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被 `disable` 的。
- 模板函数 模板函数也不能是虚函数。因为，类会在`vtbl`中存放类中的所有的虚函数的函数指针，而一个模板函数如果设计为虚函数是无法获悉这个模板函数会被实例化为哪些具体的函数。

#### **为什么需要虚析构函数，什么时候不需要? 父类的析构函数为什么要定义为虚函数**

- 一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是**为了当用一个基类的指针删除一个派生类的对象时， 派生类的析构函数会被正确调用**。
- 当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。 所以，**只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**

#### `http header`有什么内容

https://www.cnblogs.com/rachelxiao/p/12423095.html `http`面试问题集锦

#### TCP粘包问题

**“粘包问题”概念**

   “粘包问题”的概念用一句话说：就是，不同结构的多个包合成了一个大包，从而不知道怎么去把这个大包分割出原来的包。

https://blog.csdn.net/weixin_41047704/article/details/85340311?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&utm_relevant_index=12

#### 协程和线程的区别，线程与进程的区别

https://www.cnblogs.com/bandaoyu/p/14624968.html

#### 内核态和用户态

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：**系统调用，异常和中断**

#### 左值和右值

左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用；

而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值

 一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址**。**

https://blog.csdn.net/p942005405/article/details/84644101

[c++ 之 std::move 原理实现与用法总结](https://ppipp.blog.csdn.net/article/details/84644069)

在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是**将一个左值强制转化为右值引用，继而可以通过右值引用使用该值**，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);



动态多态满足的条件：

> 1. 有继承关系
> 2. 50子类**==重写==**父类的虚函数

动态类型的使用:父类的指针或者引用,执行子类对象

---

<hr>上面是分割线`---`+`空格`</hr
用户态转内核态有几种方式

- 系统调用
- 异常
- 外围设备的中断

**服务器端实现高并发**

1. TCP`socket,bind,listen...`+多线程

   - 优点：代码简单，结构清晰，把各种功能的业务代码放到线程函数里
   - 缺点：对服务器性能要求比较高，比如，虚拟机（1G内存，单核CPU，大概能够接受300个这种结构客户端的请求，如果再多，服务器创建线程时报错：内存不够）
   - 多线程只有在多核CPU上，才能体现出真正的并发优势，我们使用的阿里云轻量服务器是单核的，单核CPU使用多线程是一种伪并发，线程之间切换也需要时间
   - 综上：效率不高

2. select：文件描述符（对应一个客户端）的集合，单线程循环，对服务器性能要求相对较低，但是并发量有限（1024），处理效率低，一旦有数据可读的时候，需要循环遍历整个集合

3. epoll：对服务器性能要求相对较低，理论上并发量无限（资源毕竟有限，终将会消耗完），处理效率高，一旦有数据可读的时候，自己`epoll_event`事件结构体会直接跳出来，但是，缺点：同步（某个客户端的请求处理比较麻烦耗时，那么其他客户端在此期间的请求会监听不到）

4. epoll+多线程：解决3的缺点，epoll监听到某个客户端请求，启动一个线程，把他教给线程去处理，epoll本身继续执行监听任务，缺点：频繁启动线程，浪费时间和资源

5. epoll+线程池：解决4缺点，线程池是在服务器空闲的时候提前建立大量的线程，等待使用，处理完某个客户端请求之后，再把线程放回到线程池中

6. libevent（底层封装了epoll），集合中的事件不同于epoll中的epoll_event，叫做`buffer_event`，还封装了`TCP中的各种函数`，稳定；既然是封装了epoll，也是一种同步方式

7. 本项目：libevent+多线程，但是不同于4，因为`libevent`也是不允许多个线程同时操作事件集合`event_base`，涉及到同步问题，

   所以管理线程（监听），处理客户端请求时，新建工作线程（在这个里面再创建一个事件集合，）

   一个线程中只有一个事件，没有体现出libevent事件集合的优势

	**最好的实现方案设计：**

- 聊天等功能时，使用`libevent+单线程`，因为聊天等功能都比较简单，不会很时，造成单线程的堵塞问题
- 传输文件功能时，再启用额外的线程，处理这种比较耗时的工作

高并发下，多线程将资源会耗尽，IO多路复用，单线程处理多个请求；

登录密码如何加密不被窃取：[MD5加密+加盐salt，可以抵抗“彩虹表”（破解哈希函数类的加密算法）](https://blog.csdn.net/nie19940803/article/details/76641498?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164758739416782089378288%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164758739416782089378288&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-76641498.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%BD%A9%E8%99%B9%E8%A1%A8&spm=1018.2226.3001.4187)

---

2022/2/28下午字节懂车帝后端开发一面——凉

项目中使用链表的原因，为什么不使用数组呢

IO多路复用

[这次答应我，一举拿下 I/O 多路复用！](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

[面试官: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)

#### redis分布式锁

- setnx
- lua
- redisson
- RedLock

[面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)

[Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)

linux查看内存、cpu命令

表锁和行锁应用场景，什么条件下会触发，间隙锁

[mysql的锁🔒](https://mp.weixin.qq.com/s/ptCOFqSuMBHm_4OmFPV2dg)

redis应用场景

部署redis集群

redis数据结构，跳表

https流程说一下

redis主机宕机，从服务器升级为主服务器流程

[面试官：Redis主节点宕机，如何处理？](https://mp.weixin.qq.com/s/bifB1blF_YeWsNNIybmB4w)

tcp流量控制——by滑动窗口



拥塞控制算法

- 慢启动
- 拥塞避免

[《计算机网络》学习笔记 NO.029 TCP协议的拥塞控制](https://mp.weixin.qq.com/s/rqyc8zaW-7-pFTjO-N3p3A)

- 拥塞发生
- 快速恢复

如何区分流量控制和拥塞控制？

- 流量控制属于通信双⽅协商；拥塞控制涉及通信链路全局。
- 流量控制需要通信双⽅各维护⼀个发送窗、⼀个接收窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化由试探性发送⼀定数据量数据探查⽹络状况后⽽⾃适应调整。
- 实际最终发送窗⼝ = min{流控发送窗⼝，拥塞窗⼝}  

常用对称与非对称加密算法有哪些

先复习一下相关概念：

- 明文：指没有经过加密的信息/数据。
- 密文：明文被加密算法加密之后，会变成密文，以确保数据安全。
- 密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。
- 加密：将明文变成密文的过程。
- 解密：将密文还原为明文的过程。

对称加密算法:加密和解密使用**相同密钥**的加密算法。常见的对称加密算法有**AES、3DES、DES、RC5、RC6**等。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmRWNuUibfyQusbEibTQ1kuW4Bl7e4x0g9ra3KVjJCWFpiaKtcVH6ZxpKRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**非对称加密算法**：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。主要的非对称加密算法有：**RSA、Elgamal、DSA、D-H、ECC**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmQWfgJ9BeRH1f0CPUhhTBO7POHoLwwUibkjdLwepWkgFCP0kNXpSwm9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

零拷贝

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

红黑树、B+树

算法题：爬楼梯，O(n)和O(1)空间复杂度都实现一下

反馈：项目过于简单，找一些秒杀系统商城项目跑一跑，知识点过于单一



---

#### 为什么[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)比链表查询速度更快？

- 数组由于是紧凑连续存储,可以随机访问，通过**索引**快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
- 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

数组(**顺序存储**)和链表（**链式存储**）有以下不同：

**数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。**

1. 存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个节点要保存相邻结点指针；
2. 数据查找：数组的**线性查找速度快，查找操作直接使用偏移地址**。链表需要**按顺序检索结点**，效率低；
3. 数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动；
4. **越界问题**：链表不存在越界问题，数组有越界问题。

#### 进程间通信

即IPC机制——Inter-Process Communication

[凉了！张三同学没答好「进程间通信」，被面试官挂了....————————小林大佬，面试回答总结部分](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)

**什么是虚拟内存**

> 虚拟内存，是虚拟出来的内存，它的核心思想就是确保每个程序拥有自己的地址空间，地址空间被分成多个块，每一块都有连续的地址空间。同时物理空间也分成多个块，块大小和虚拟地址空间的块大小一致，操作系统会自动将虚拟地址空间映射到物理地址空间，程序只需关注虚拟内存，请求的也是虚拟内存，真正使用却是物理内存。

现代操作系统使用**虚拟内存**，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：

- 虚拟内存空间可以远远大于物理内存空间
- 多个虚拟内存可以指向同一个物理地址

##### [看零拷贝之传统IO、mmap、sendfile、sendfile再优化](https://blog.csdn.net/Youth_lql/article/details/115524139)

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

**零拷贝**实现思想，就利用了**虚拟内存**这个点：多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，**就可以减少IO的数据拷贝次数啦**，示意图如下：

![image-20220303195205781](C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220303195205781.png)

[面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

> 1. 排序链表
>
> 2. 对称与非对称加密算法的区别
>
> 3. TCP如何保证可靠性
>
> 4. 聊聊五种IO模型
>
>    5. hystrix 工作原理
>
> 6. 延时场景处理
>
> 7. https请求过程
>
> 8. **聊聊事务隔离级别，以及可重复读实现原理**
>
> 9. 聊聊索引在哪些场景下会失效？
>
> 10. 什么是虚拟内存
>
> 11. 排行榜的实现，比如高考成绩排序
>
> 12. 分布式锁实现
>
> 13. 聊聊零拷贝
>
> 14. 聊聊synchronized
>
> 15. 分布式ID生成方案

[多线程访问共享资源——面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ)

[MySQL主从复制原理以及过程以及用到的三个重要线程](https://blog.csdn.net/jiayoudangdang/article/details/123167600)

[跳表：为什么 [Redis]一定要用跳表来实现有序集合？](https://blog.csdn.net/qq_38545713/article/details/105439688)

[在RR级别下，mysql通过间隙锁可以防止幻读——插入](https://blog.csdn.net/m0_37556444/article/details/104479489)

#### innodb自动使用间隙锁的条件：

（1）必须在RR级别下（**解决幻读**）
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）

[如何分配客户端的请求给服务器（节点）进行处理，一致性哈希是什么，使用场景，解决了什么问题？](https://mp.weixin.qq.com/s/Os2JOInK5PBLBCwUzh8Jfg)

[**那你再跟我说说Redis如何实现高可用吧？**](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)

[Redis高可用方案：sentinel（哨兵模式）和集群](https://mp.weixin.qq.com/s/2LDkEMXDLAHroyr0uFb9sQ)

- 主从复制
- 哨兵``
- 集群`cluster`

int i;//定义一个int类型的变量i

size_t size=sizeof(i);//用sizeof操作得到变量i的类型的大小

#### **Linux常见命令：**

`/proc` 目录下都是虚拟文件，包含内核以及操作系统相关的动态信息

- linux下如何查看cpu信息——可以从文件cpuinfo读取，`cat /proc/cpuinfo`，可以查看几个cpu、单个cpu的物理核数、总逻辑核数等
- [linux系统命令之查看内存使用情况](https://blog.csdn.net/renfufei/article/details/105851728)
  - 包括物理内存RAM和交换内存
    - 使用`free -m`命令
    - 查看`/proc/meminfo`文件
    - 使用`vmstat -s`命令
    - `top` 命令一般用于查看进程的CPU和内存使用情况；当然也会报告内存总量，以及内存使用情况，所以可用来监控物理内存的使用情况
  - 查看物理内存的硬件信息，可以使用 `demidecode` 命令
- 查询操作系统中的进程——`ps或者top（进程的CPU和内存使用情况）` 
- 查看端口号命令——` lsof 和 netstat命令`
- 怎样更改文件的所属用户：`chown`

==mysql如何判断事务是否提交了==

#### 在浏览器中输入**url**地址后显示主页的过程?  

- 根据域名，进行**DNS域名解析**；
- 拿到解析的IP地址，建立TCP连接；  
- 向IP地址，发送HTTP请求；
- 服务器处理请求；
- 返回响应结果；
- 关闭TCP连接；
- 浏览器解析HTML；浏览器布局渲染；  

#### DNS域名解析过程

（找到客户端发起的某个web服务器（域名：www.baidu.com）对应的IP地址)

浏览器的缓存——>系统hosts文件——>本地DNS服务器——>根域名服务器——>顶级域名服务器——>权限域名服务器。

两种查询方式：==微信收藏文章看图片==

递归查询：本地域名服务器作为DNS客户端的身份，递归的方式向其他更高级别的域名服务器进行递归查询，代替主机/客户端查询

迭代查询：当根域名服务器x本地服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该找哪个域名服务器y进行查询，然后本地服务器向y进行相同方式的迭代查询



#### **SYN攻击是什么？**

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间**占用未连接队列**，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基
本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击  。

`netstats -n -p TCP | grep SYN_RECV`

- [x] 内链接、左联结、右联结的区别————csdn八股文收藏

- [ ] 数据库的关联方式有哪些

- [x] 解释一下快速重传和超时重传的区别

  79、TCP四大拥塞控制算法总结？（极其重要）  ——————拓跋阿秀的八股文

  

- [x] 快速重传为什么是3次ack以后才开始

  - 主要是为了区分包的丢失，是由什么原因引起的
    - 1、包checksum出错
    - 2、网络拥塞
    - 3、网路断
  - 如果在反向还可以接受到发送数据包的ack，可以认为网络没有断，否则也收不到ack，排除3
  - 如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，
    接收方会进行排序工作  
  - 如果接收到三个或三个以上的duplicated ACK，则大概率是丢包  ，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，说明先前的发送的包出错了，则一切OK，流速依然。  而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理  

- [ ] 场景题：输入一段url，发送了http请求，但是其中请求数据包产生了丢包的情况，但是服务端却返回了200（成功）的状态码，请解释原因

- [x] 代码题

- 面试题16.10 生存人数（求多个区间的最大重合数量，及其对应的区间）——前缀和

- 数组中的第K个最大元素——快排

- 给出0和1构成的二维数组，找出全部由0或者1构成的正方形边的最大值，——动态规划==[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)==

- [[380. O(1) 时间插入、删除和获取随机元素]](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/solution/chang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-j/)

  - 动态数组存储插入元素，哈希表存储元素在数组中的索引位置
  - 删除元素，首先判断是否在哈希表中，若存在，找到其索引`curInd`，在数组中交换索引`curInd`与`len-1`对应的值，将交换后的数组末尾元素删除，将其在哈希表中的索引也删除，同时更新原来末尾元素在哈希表中的索引为`curIdx`
  - 返回随机元素，`return nums(rand() % len);`

- [719找出第k小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

  - 双指针+二分法

  - 类似于————第k小的子数组和

    ```c++
    // 保证数组元素均为>= 0
    #include <bits/stdc++.h>
    using namespace std;
    int check(vector<int> &nums, int mid) { // 双指针法求小于等于mid的连续子数组个数
        int res = 0;
        int i = 0;
        int preSum = 0;
        for (int j = 0; j < nums.size(); j++) {
            preSum += nums[j];
            while (preSum > mid) { // 不必限制i <= j
                preSum -= nums[i];
                i++;
            }
            res += j - i + 1; // [i, j]可以组成(i)/(i,i+1)/(i,i+2)...(i,j-1)/(i,j)共i - j + 1个连续子数组
        }
    }
    int num_k_less_sum(vector<int> &nums, int k) { // 二分法求第k小的子数组和
        int l = 0, r = 1e9, mid, ans; // l为可能存在的最小数组和，r为最大
        while (l <= r) {
            mid = (l + r) >> 1;
            if (check(nums, mid) >= k) { // 子数组和小于等于mid的个数多于k个，说明r过大，需要缩小 
    			r = mid - 1;
                ans = mid; // 记录结果
            } 
            else {
                l = mid + 1;
            }
        }
        return ans;
    }
    int main() {
        int n, k;
        cin >> n >> k;
        vector<int> nums(n, 0);
        for (int i = 0; i < n; i++) {
            int num;
            cin >> num;
            nums[i] = num;
        }
        cout << num_k_less_sum(nums, k) << endl;
    }
    ```


- [694 不同岛屿（形状不同）的数量](https://blog.csdn.net/weixin_44171872/article/details/109014435)

  ```C++
  class solution {
  public:
      int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1}; // 上下左右
      int numDistinctIslands(vector<vector<int>>& grid) {
          set<vector<int>> st; // 该set集合中的元素vector是某个岛屿相对其左上角的坐标
          for (int i = 0; i < grid.size(); i++) {
              for (int j = 0; j < grid[0].size(); j++) {
                  if (grid[i][j] == 1) { // 发现岛屿的左上角节点(i,j)
                      queue<int> q; // BFS用
                      vector<int> cur; // 存储当前岛屿相对于grid[i][j]的坐标
                      q.push(i);
                      q.push(j);
                      grid[i][j] = 0; // 标记
                      while (!q.empty()){
                          int x = q.front();
                          q.pop();
                          int y = q.front();
                          q.pop();
                          // 将偏移节点坐标插入cur
                          cur.push_back(x - i);
                          cur.push_back(y - j);
                          for (int k = 0; k < 4; k++) { // bfs遍历
                          	int ni = x + dx[k], nj = y + dy[k];
                          	if (ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size() && grid[ni][nj] == 1) {
                              	grid[ni][nj] == 0; // 标记
                                  q.push(ni);
                                  q.push(nj);
                          	}
                      	}
                      }
                      st.insert(cur); // 将当前岛屿的形状坐标vector插入set中，形状相同的岛屿vector<int> cur也相同，set会自动去重
                  }
              }
          }
          return st.size(); // set集合的大小就是不同形状岛屿的数量
      }
  }
  ```

  

#### 所谓==慢查询==

是指在Mysql中执行时间超过指定阈值的语句将被记录到慢查询文件中

 [你好，面试官 | 分析一下SQL执行慢的原因？如何排查，优化思路？（加餐篇）](https://mp.weixin.qq.com/s/XtjVp363Rev6EBHRzPtbhA)

- 有序数组删除重复数字

目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。**分布式的CAP理论**告诉我们“任何一个分布式系统都无法同时满足**一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）**，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要**牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性**”，只要这个最终时间是在用户可以接受的范围内即可。

[Redis 主从复制以及主从复制原理](https://mp.weixin.qq.com/s/NL-eSf5EXLtVZgDfC_q-LQ)

#### **TCP如何保证可靠性**

- 首先，TCP的连接是基于三次握手，而断开则是四次挥手。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在有状态;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在可控制。它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

**虚函数表存放位置？linux全局数据区，windows常量段**[C++中虚函数、虚指针和虚表详解](https://blog.csdn.net/qq_20817327/article/details/108859161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164760442916780271554589%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164760442916780271554589&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-108859161.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8&spm=1018.2226.3001.4187)

**虚拟化**可以将一台主机划分为多个操作系统，每个操作系统还有独立的cpu资源，存储资源，内存资源。充分的利用的硬件资源。我知道的虚拟化产品：vmware 、MS

常见的几种**dos攻击**

答：tcp syn泛洪 ，ping泛洪，udp泛洪等等

3.20深信服C++开发工程师电话面：

- 用过哪些redis数据结构（使用场景），查看端口号命令、 iptables，docker，讲一讲项目中遇到的困难（具体），怎么解决的，登录解密的密钥，分组加密，长连接：超时时间、真正的长连接、学习go和python

#### 常量指针和指针常量的区别：

> const pointer，指针本身是一个常量，指向的地址不能改变，里面的内容可以修改。（门牌号11，不管里面住谁，我指向的都是这条街11号）
> pointer to const，指向的内容是一个常量，可以改变指向的地址，只要新地址里面也是常量就好。（小明原来住在六舍356，后来搬到357，不管是356还是357，里面住的都是小明）
>
> 当然如果单纯为了区别两个中文，那么const=常量，*=指针，看谁在谁前面就叫对应的名字。

[**倒排索引(Inverted Index)**](https://blog.csdn.net/hguisu/article/details/7962350?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164791892916782089327763%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164791892916782089327763&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-7962350.142^v2^pc_search_result_cache,143^v4^control&utm_term=%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。

# [MySQL解决幻读——MVCC与临键锁](https://blog.csdn.net/QAQ123666/article/details/105084758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164792119816780265410477%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164792119816780265410477&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-105084758.142^v3^pc_search_result_cache,143^v4^control&utm_term=mvcc%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB&spm=1018.2226.3001.4187)

当前读：读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。

> 　select...lock in share mode (共享读锁) 
>
> 　select...for update（行级锁）
>
> 　update , delete , insert

快照读：快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

> ​	不加锁的select操作

**在RR级别下，==快照读/普通读==是通过[MVVC(多版本控制)+undo log](https://blog.csdn.net/weixin_45325628/article/details/123292887?spm=1001.2014.3001.5502)来实现的，==当前读==是通过加record lock(记录锁/行锁)和gap lock(间隙锁)来实现的。**

当前读的幻读与解决方式：临键锁next-key locks = 行锁+间隙锁，在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。select * from table where id>3 锁住的就是id=3这条记录以及id>3这个区间范围，锁住索引记录之间的范围，避免范围间**插入**记录，以避免**产生幻影行**记录；

> 行锁（Record Lock）：锁直接加在索引记录上面。
>
> 间隙锁（Gap Lock）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。
>
> Next-Key Lock ：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身 。

**mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。**

**快照读的幻读是用MVCC解决的，当前读的幻读是用间隙锁解决的。**

CAS和ABA问题

面试加分项：

**==对分布式的了解？==**

首先说一下cap和base理论，然后往分布式锁、负载均衡、redis集群高可用，去主动靠

> **CAP**
>
> CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
>
> - 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
> - 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
> - 分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

> **BASE理论**
>
> BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
>
> - Basically Available（基本可用）
> - Soft state（软状态）
> - Eventually consistent（最终一致性）

- 分布式系统设计与开发
  - 分布式缓存
  - 分布式锁
    - [面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)
    - [Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)
- 分布式事务(解决方案)
- 负载均衡技术（在nginx服务器中配了3个tomcat服务器，每个tomcat服务器上都部署了整个系统，那么当请求数大的时候，可以分发到不同的tomcat。）
- 一致性哈希算法：很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。
  - 哈希环（通过虚拟节点提高均衡度）、redis哈希槽

- 系统容灾技术————mysql主从复制，redis持久化，哨兵监控、主复制写，从负责读
- 高可用系统————主从复制、哨兵监控（自动故障转移、恢复），集群（扩展单一服务器写能力和存储能力不足）

### C++基础

#### 1.static

```c++
控制变量的存储方式和可见性。 

(1)修饰局部变量
一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

(2)修饰全局变量
对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。

(3)修饰函数
用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

(4)C++中的static
如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的
```

#### 2.const的含义及使用场景和作用

```C++
const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。
 
(1)const修饰基本数据类型

 1.const修饰一般常量及数组
  
 基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 
  
 2.const修饰指针变量*及引用变量&  
 
如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

(2)const应用到函数中,  

 1.作为参数的const修饰符
 
 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。
 [注意]：参数const通常用于参数为指针或引用的情况; 
 
 2.作为函数返回值的const修饰符
 
 声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。
(3)const在类中的用法

不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行
类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。

(4)const修饰类对象，定义常量对象 
常量对象只能调用常量函数，别的成员函数都不能调用。
```

#### 3.extern

```C++
在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

注意 extern 声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
```

#### 4.define宏定义与内联函数

```c++
内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令
在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
内联函数有类型检测、语法判断等功能，而宏没有
内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样
  
内联函数适用场景:
使用宏定义的地方都可以使用 inline 函数。
作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。
    
```

#### 5.虚函数： 虚函数的作用和实现原理，什么是虚函数,有什么作用?

```c++
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。	
	
虚函数实现原理:包括虚函数表、虚函数指针等 

虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。
```

#### 6.纯虚函数，为什么需要纯虚函数？

```c++
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

virtual void funtion1()=0

原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)
```

#### 7.[虚析构函数（√）、纯虚析构函数（√）、虚构造函数（X）](https://www.cnblogs.com/chio/archive/2007/09/10/888260.html)

#### 8.[linux开机启动过程详细介绍](https://blog.csdn.net/yujia_666/article/details/108029382?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164855850116780366584894%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164855850116780366584894&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-108029382.142^v5^pc_search_result_cache,143^v6^control&utm_term=linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B&spm=1018.2226.3001.4187)

#### 9.vector迭代器失效

#### 10. [Bitmap有什么用大量数据的快速排序、查找、去重](https://www.cnblogs.com/cjsblog/p/11613708.html)

#### 11.10亿个数字，内存限制100M，进行排序

>  分治法：拆分小文件，先对每个小文件进行排序，然后使用小顶堆或大顶堆合并文件

#### 12.[如何保证mysql和redis的数据一致性？](https://www.cnblogs.com/shier-dong/p/15347134.html)

