## 我的八股文

1. 快排，时间复杂度为`O(nlog2n)`，空间复杂度为`O(log2n)`;

2. 常见的I/O编程框架

   对比几个常见的I/O编程框架：libevent，libev，libuv，aio，boost.Asio。

   libevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。
   设计模式 ：libevent为Reactor模式；
   层次架构：livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务；
   可移植性 ：libevent主要支持linux平台，freebsd平台，其他平台下通过select模型进行支持，效率不是太高；
   事件分派处理 ：libevent基于注册的事件回调函数来实现事件分发；
   涉及范围 ：libevent只提供了简单的网络API的封装，线程池，内存池，递归锁等均需要自己实现；
   线程调度 ：libevent的线程调度需要自己来注册不同的事件句柄；
   发布方式 ：libevent为开源免费的，一般编译为静态库进行使用；
   开发难度 ：基于libevent开发应用，相对容易，具体可以参考memcached这个开源的应用，里面使用了 libevent这个库。

3. linux命令`|`是无名管道，linux命令`mkfifo`是==命名管道==

C++中虚函数是说白了就是父类定义为虚函数（关键词Virtual）并实现，子类可以继承函数名并重新实现函数过程，这样子类对象调用虚函数时就调到了自己实现的函数体里，跟父类没有关系了（当然可以用[父类名::虚函数名]来调用父类虚函数实现方法），这就实现了多态性。
纯虚函数不同的是父类绝对不能实现，且不能实例化，子类必须实现父类定义的虚函数接口，除非它也想成为抽象类，抽象类可以有部分方法实现，但至少要有一个纯虚函数的类才能叫抽象类。

```c++
Class B
{
public:
    virtual void fun1(){ cout << "fun1";} //虚函数，子类不用声明或实现
    virtual void fun2 = 0; //纯虚函数，子类必须声明并实现
};
```

`http header`有什么内容

https://www.cnblogs.com/rachelxiao/p/12423095.html `http`面试问题集锦

TCP粘包问题

**“粘包问题”概念**

   “粘包问题”的概念用一句话说：就是，不同结构的多个包合成了一个大包，从而不知道怎么去把这个大包分割出原来的包。

https://blog.csdn.net/weixin_41047704/article/details/85340311?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-8.pc_relevant_aa&utm_relevant_index=12

协程和线程的区别，线程与进程的区别

https://www.cnblogs.com/bandaoyu/p/14624968.html

内核态和用户态

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断

左值和右值

左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用；

而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值

 一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址**。**

https://blog.csdn.net/p942005405/article/details/84644101

[c++ 之 std::move 原理实现与用法总结](https://ppipp.blog.csdn.net/article/details/84644069)

在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);



动态多态满足的条件：

> 1. 有继承关系
> 2. 子类**==重写==**父类的虚函数

动态类型的使用:父类的指针或者引用,执行子类对象

---

<hr>上面是分割线`---`+`空格`</hr
用户态转内核态有几种方式

- 系统调用
- 异常
- 外围设备的中断

**服务器端实现高并发**

1. TCP`socket,bind,listen...`+多线程

   - 优点：代码简单，结构清晰，把各种功能的业务代码放到线程函数里
   - 缺点：对服务器性能要求比较高，比如，虚拟机（1G内存，单核CPU，大概能够接受300个这种结构客户端的请求，如果再多，服务器创建线程时报错：内存不够）
   - 多线程只有在多核CPU上，才能体现出真正的并发优势，我们使用的阿里云轻量服务器是单核的，单核CPU使用多线程是一种伪并发，线程之间切换也需要时间
   - 综上：效率不高

2. select：文件描述符（对应一个客户端）的集合，单线程循环，对服务器性能要求相对较低，但是并发量有限（1024），处理效率低，一旦有数据可读的时候，需要循环遍历整个集合

3. epoll：对服务器性能要求相对较低，理论上并发量无限（资源毕竟有限，终将会消耗完），处理效率高，一旦有数据可读的时候，自己`epoll_event`事件结构体会直接跳出来，但是，缺点：同步（某个客户端的请求处理比较麻烦耗时，那么其他客户端在此期间的请求会监听不到）

4. epoll+多线程：解决3的缺点，epoll监听到某个客户端请求，启动一个线程，把他教给线程去处理，epoll本身继续执行监听任务，缺点：频繁启动线程，浪费时间和资源

5. epoll+线程池：解决4缺点，线程池是在服务器空闲的时候提前建立大量的线程，等待使用，处理完某个客户端请求之后，再把线程放回到线程池中

6. libevent（底层封装了epoll），集合中的事件不同于epoll中的epoll_event，叫做`buffer_event`，还封装了`TCP中的各种函数`，稳定；既然是封装了epoll，也是一种同步方式

7. 本项目：libevent+多线程，但是不同于4，因为`libevent`也是不允许多个线程同时操作事件集合`event_base`，涉及到同步问题，

   所以管理线程（监听），处理客户端请求时，新建工作线程（在这个里面再创建一个事件集合，）

   一个线程中只有一个事件，没有体现出libevent事件集合的优势

	最好的实现方案设计：

- 聊天等功能时，使用`libevent+单线程`，因为聊天等功能都比较简单，不会很时，造成单线程的堵塞问题
- 传输文件功能时，再启用额外的线程，处理这种比较耗时的工作



---

2022/2/28下午字节懂车帝后端开发一面——凉

项目中使用链表的原因，为什么不使用数组呢

IO多路复用

[这次答应我，一举拿下 I/O 多路复用！](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

[面试官: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)

redis分布式锁

- setnx
- redisson
- RedLock

[面试问题：Redis 分布式锁的细节](https://mp.weixin.qq.com/s/ZOFjroVyBjSCD6azdWIKkw)

[Redis分布式锁，你用对了吗？](https://mp.weixin.qq.com/s/gCiAG7uaap7ea7_fdKuoqw)

linux查看内存、cpu命令

表锁和行锁应用场景，什么条件下会触发，间隙锁

[mysql的锁🔒](https://mp.weixin.qq.com/s/ptCOFqSuMBHm_4OmFPV2dg)

redis应用场景

部署redis集群

redis数据结构，跳表

https流程说一下

redis主机宕机，从服务器升级为主服务器流程

[面试官：Redis主节点宕机，如何处理？](https://mp.weixin.qq.com/s/bifB1blF_YeWsNNIybmB4w)

tcp流量控制——by滑动窗口



拥塞控制算法

- 慢启动
- 拥塞避免

[《计算机网络》学习笔记 NO.029 TCP协议的拥塞控制](https://mp.weixin.qq.com/s/rqyc8zaW-7-pFTjO-N3p3A)

- 拥塞发生
- 快速恢复

如何区分流量控制和拥塞控制？

- 流量控制属于通信双⽅协商；拥塞控制涉及通信链路全局。
- 流量控制需要通信双⽅各维护⼀个发送窗、⼀个接收窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化由试探性发送⼀定数据量数据探查⽹络状况后⽽⾃适应调整。
- 实际最终发送窗⼝ = min{流控发送窗⼝，拥塞窗⼝}  

常用对称与非对称加密算法有哪些

先复习一下相关概念：

- 明文：指没有经过加密的信息/数据。
- 密文：明文被加密算法加密之后，会变成密文，以确保数据安全。
- 密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。
- 加密：将明文变成密文的过程。
- 解密：将密文还原为明文的过程。

对称加密算法:加密和解密使用**相同密钥**的加密算法。常见的对称加密算法有**AES、3DES、DES、RC5、RC6**等。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmRWNuUibfyQusbEibTQ1kuW4Bl7e4x0g9ra3KVjJCWFpiaKtcVH6ZxpKRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**非对称加密算法**：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。主要的非对称加密算法有：**RSA、Elgamal、DSA、D-H、ECC**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzLBV5zbOkvrsTxZqbOic8vmQWfgJ9BeRH1f0CPUhhTBO7POHoLwwUibkjdLwepWkgFCP0kNXpSwm9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

零拷贝

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

红黑树、B+树

算法题：爬楼梯，O(n)和O(1)空间复杂度都实现一下

反馈：项目过于简单，找一些秒杀系统商城项目跑一跑，知识点过于单一



---

为什么[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)比链表查询速度更快？

- 数组由于是紧凑连续存储,可以随机访问，通过**索引**快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
- 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

数组(**顺序存储**)和链表（**链式存储**）有以下不同：

**数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。**

1. 存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个节点要保存相邻结点指针；
2. 数据查找：数组的**线性查找速度快，查找操作直接使用偏移地址**。链表需要**按顺序检索结点**，效率低；
3. 数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动；
4. **越界问题**：链表不存在越界问题，数组有越界问题。

进程间通信

即IPC机制——Inter-Process Communication

[凉了！张三同学没答好「进程间通信」，被面试官挂了....————————小林大佬，面试回答总结部分](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)

**什么是虚拟内存**

> 虚拟内存，是虚拟出来的内存，它的核心思想就是确保每个程序拥有自己的地址空间，地址空间被分成多个块，每一块都有连续的地址空间。同时物理空间也分成多个块，块大小和虚拟地址空间的块大小一致，操作系统会自动将虚拟地址空间映射到物理地址空间，程序只需关注虚拟内存，请求的也是虚拟内存，真正使用却是物理内存。

现代操作系统使用**虚拟内存**，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：

- 虚拟内存空间可以远远大于物理内存空间
- 多个虚拟内存可以指向同一个物理地址

[看零拷贝之传统IO、mmap、sendfile、sendfile再优化](https://blog.csdn.net/Youth_lql/article/details/115524139)

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

**零拷贝**实现思想，就利用了**虚拟内存**这个点：多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，**就可以减少IO的数据拷贝次数啦**，示意图如下：

![image-20220303195205781](C:\Users\a'd'mia\AppData\Roaming\Typora\typora-user-images\image-20220303195205781.png)

[面试必备：虾皮服务端15连问](https://mp.weixin.qq.com/s/b5r_gPzdaL6pUWojiihEig)

> 1. 排序链表
>
> 2. 对称与非对称加密算法的区别
>
> 3. TCP如何保证可靠性
>
> 4. 聊聊五种IO模型
>
>    
>
> 5. hystrix 工作原理
>
> 6. 延时场景处理
>
> 7. https请求过程
>
> 8. **聊聊事务隔离级别，以及可重复读实现原理**
>
> 9. 聊聊索引在哪些场景下会失效？
>
> 10. 什么是虚拟内存
>
> 11. 排行榜的实现，比如高考成绩排序
>
> 12. 分布式锁实现
>
> 13. 聊聊零拷贝
>
> 14. 聊聊synchronized
>
> 15. 分布式ID生成方案

[多线程访问共享资源——面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ)

[MySQL主从复制原理以及过程以及用到的三个重要线程](https://blog.csdn.net/jiayoudangdang/article/details/123167600)

[跳表：为什么 [Redis]一定要用跳表来实现有序集合？](https://blog.csdn.net/qq_38545713/article/details/105439688)

[在RR级别下，mysql通过间隙锁可以防止幻读——插入](https://blog.csdn.net/m0_37556444/article/details/104479489)

#### innodb自动使用间隙锁的条件：

（1）必须在RR级别下（**解决幻读**）
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）

[如何分配客户端的请求给服务器（节点）进行处理，一致性哈希是什么，使用场景，解决了什么问题？](https://mp.weixin.qq.com/s/Os2JOInK5PBLBCwUzh8Jfg)

[**那你再跟我说说Redis如何实现高可用吧？**](https://mp.weixin.qq.com/s/9TIy34NMY8pz1swJFXVWeg)

- 主从复制
- 哨兵``
- 集群`cluster`

int i;//定义一个int类型的变量i

size_t size=sizeof(i);//用sizeof操作得到变量i的类型的大小

**Linux常见命令：**

`/proc` 目录下都是虚拟文件，包含内核以及操作系统相关的动态信息

- linux下如何查看cpu信息——可以从文件cpuinfo读取，`cat /proc/cpuinfo`，可以查看几个cpu、单个cpu的物理核数、总逻辑核数等
- [linux系统命令之查看内存使用情况](https://blog.csdn.net/renfufei/article/details/105851728)
  - 包括物理内存RAM和交换内存
    - 使用`free -m`命令
    - 查看`/proc/meminfo`文件
    - 使用`vmstat -s`命令
    - `top` 命令一般用于查看进程的CPU和内存使用情况；当然也会报告内存总量，以及内存使用情况，所以可用来监控物理内存的使用情况
  - 查看物理内存的硬件信息，可以使用 `demidecode` 命令
- 查询操作系统中的进程——`ps或者top（进程的CPU和内存使用情况）`
- 怎样更改文件的所属用户：`chown`

==mysql如何判断事务是否提交了==

